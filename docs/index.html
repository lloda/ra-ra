<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- ra:: (version 8, updated 2019 June 11)

(c) Daniel Llorens 2005-2019

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. -->
<!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>ra:: —An array library for C++17</title>

<meta name="description" content="ra:: —An array library for C++17">
<meta name="keywords" content="ra:: —An array library for C++17">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="#Top" rel="start" title="Top">
<link href="#Indices" rel="index" title="Indices">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<h1 class="settitle" align="center">ra:: —An array library for C++17</h1>



















































<span id="Top"></span><div class="header">
<p>
Next: <a href="#Overview" accesskey="n" rel="next">Overview</a>, Up: <a href="dir.html#Top" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="ra_003a_003a"></span><h1 class="top"><code>ra::</code></h1>

<p><code>ra::</code> (version 8, updated 2019 June 11)
</p>
<p>(c) Daniel Llorens 2005&ndash;2019
</p>
<div class="display">
<pre class="display">Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
</pre></div>

<p><code>ra::</code><a id="DOCF1" href="#FOOT1"><sup>1</sup></a> is a general purpose multidimensional array and expression template library for C++17. Please keep in mind that this manual is a work in progress. There are many errors and whole sections unwritten.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Overview" accesskey="1">Overview</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Array programming and C++.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Usage" accesskey="2">Usage</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Everything you can do with <code>ra::</code>.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Extras" accesskey="3">Extras</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Additional libraries provided with <code>ra::</code>.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Hazards" accesskey="4">Hazards</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">User beware.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Internals" accesskey="5">Internals</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">For all the world to see.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-future" accesskey="6">The future</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Could be even better.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Reference" accesskey="7">Reference</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Systematic list of types and functions.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Sources" accesskey="8">Sources</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">It&rsquo;s been done before.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Indices" accesskey="9">Indices</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Or try the search function.
</td></tr>
</table>



<hr>
<span id="Overview"></span><div class="header">
<p>
Next: <a href="#Usage" accesskey="n" rel="next">Usage</a>, Previous: <a href="#Top" accesskey="p" rel="prev">Top</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Overview-1"></span><h2 class="chapter">1 Overview</h2>

<p>A multidimensional array is a container whose elements can be looked up using a multi-index (i₀, i₁, ...). Each of the indices i₀, i₁, ... has a constant range [0, n₀), [0, n₁), ... independent of the values of the other indices, so the array is ‘rectangular’. The number of indices in the multi-index is the <em>rank</em> of the array, and the list (n₀, n₁, ... nᵣ₋₁) is the <em>shape</em> of the array. We speak of a rank-<em>r</em> array or of an <em>r</em>-array.
</p>
<p>Often we deal with multidimensional <em>expressions</em> where the elements aren&rsquo;t stored anywhere, but are computed on demand when the expression is looked up. In this general sense, an ‘array’ is just a function of integers with a rectangular domain.
</p>
<p>Arrays (in the form of <em>matrices</em>, <em>vectors</em>, or <em>tensors</em>) are very common objects in math and programming, and it is enormously useful to be able to manipulate arrays as individual entities rather than as aggregates. Not only is
</p>
<pre class="verbatim">A = B+C;
</pre>
<p>much more compact and easier to read than
</p>
<pre class="verbatim">for (int i=0; i!=m; ++i)
    for (int j=0; j!=n; ++j)
        for (int k=0; k!=p; ++k)
            A(i, j, k) = B(i, j, k)+C(i, j, k);
</pre>
<p>but it&rsquo;s also safer and less redundant. For example, the order of the loops may be something you don&rsquo;t really care about.
</p>
<p>However, if array operations are implemented naively, a piece of code such as <code>A=B+C</code> may result in the creation of a temporary to hold <code>B+C</code> which is then assigned to <code>A</code>. Needless to say this is very wasteful if the arrays involved are large.
</p>
<span id="index-Blitz_002b_002b"></span>
<p>Fortunately the problem is almost as old as aggregate data types, and other programming languages have addressed it with optimizations such as <a href="https://en.wikipedia.org/wiki/Loop_fission_and_fusion">‘loop fusion’</a>, ‘drag along’ [<a href="#Sources">Abr70</a>]
, or ‘deforestation’ [<a href="#Sources">Wad90</a>]
. In the C++ context the technique of ‘expression templates’ was pioneered in the late 90s by libraries such as Blitz++ [<a href="#Sources">bli17</a>]
. It works by making <code>B+C</code> into an ‘expression object’ which holds references to its arguments and performs the sum only when its elements are looked up. The compiler removes the temporary expression objects during optimization, so that <code>A=B+C</code> results (in principle) in the same generated code as the complicated loop nest above.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Rank-polymorphism" accesskey="1">Rank polymorphism</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">What makes arrays special.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Drag-along-and-beating" accesskey="2">Drag along and beating</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">The basic array optimizations.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Why-C_002b_002b" accesskey="3">Why C++</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">High level, low level.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Guidelines" accesskey="4">Guidelines</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">How <code>ra::</code> tries to do things.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Other-libraries" accesskey="5">Other libraries</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Inspiration and desperation.
</td></tr>
</table>

<hr>
<span id="Rank-polymorphism"></span><div class="header">
<p>
Next: <a href="#Drag-along-and-beating" accesskey="n" rel="next">Drag along and beating</a>, Up: <a href="#Overview" accesskey="u" rel="up">Overview</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Rank-polymorphism-1"></span><h3 class="section">1.1 Rank polymorphism</h3>

<p><em>Rank polymorphism</em> is the ability to treat an array of rank <em>r</em> as an array of lower rank where the elements are themselves arrays.
</p>
<span id="index-cell"></span>
<span id="index-frame"></span>
<p>For example, think of a matrix A, a 2-array with sizes (n₀, n₁) where the elements A(i₀, i₁) are numbers. If we consider the subarrays (rows) A(0, ...), A(1, ...), ..., A(n₀-1, ...) as individual elements, then we have a new view of A as a 1-array of size n₀ with those rows as elements. We say that the rows A(i₀)≡A(i₀, ...) are the 1-<em>cells</em> of A, and the numbers A(i₀, i₁) are 0-cells of A. For an array of arbitrary rank <em>r</em> the (<em>r</em>-1)-cells of A are called its <em>items</em>. The prefix of the shape (n₀, n₁, ... nₙ₋₁₋ₖ) that is not taken up by the k-cell is called the k-<em>frame</em>.
</p>
<p>An obvious way to store an array in linearly addressed memory is to place its items one after another. So we would store a 3-array as
</p>
<blockquote>
<p>A: [A(0), A(1), ...]
</p></blockquote>

<p>and the items of A(i₀), etc. are in turn stored in the same way, so
</p>
<blockquote>
<p>A: [A(0): [A(0, 0), A(0, 1) ...], ...]
</p></blockquote>

<p>and the same for the items of A(i₀, i₁), etc.
</p>
<blockquote>
<p>A: [[A(0, 0): [A(0, 0, 0), A(0, 0, 1) ...], A(0, 1): [A(0, 1, 0), A(0, 1, 1) ...]], ...]
</p></blockquote>

<span id="index-order_002c-row_002dmajor"></span>
<p>This way to lay out an array in memory is called <em>row-major order</em> or <em>C-order</em>, since it&rsquo;s the default order for built-in arrays in C (see <a href="#Other-libraries">Other libraries</a>). A row-major array A with sizes (n₀, n₁, ... nᵣ₋₁) can be looked up like this:
</p>
<span id="x_002dstrides"></span><blockquote>
<p>A(i₀, i₁, ...) = (storage-of-A) [(((i₀n₁ + i₁)n₂ + i₂)n₃ + ...)+iᵣ₋₁] = (storage-of-A) [o + s₀i₀ + s₁i₁ +  ...]
</p></blockquote>

<p>where the numbers (s₀, s₁, ...) are called the <em>strides</em><a id="DOCF2" href="#FOOT2"><sup>2</sup></a>. Note that the ‘linear’ or ‘raveled’ address [o + s₀i₀ + s₁i₁ +  ...] is an affine function of (i₀, i₁, ...). If we represent an array as a tuple
</p>
<blockquote>
<p>A ≡ ((storage-of-A), o, (s₀, s₁, ...))
</p></blockquote>

<p>then any affine transformation of the indices can be achieved simply by modifying the numbers (o, (s₀, s₁, ...)), with no need to touch the storage. This includes very common operations such as: <a href="#x_002dtranspose">transposing</a> axes, <a href="#x_002dreverse">reversing</a> the order along an axis, most cases of <a href="#Slicing">slicing</a>, and sometimes even reshaping or tiling the array.
</p>
<p>A basic example is obtaining the i₀-th item of A:
</p>
<blockquote>
<p>A(i₀) ≡ ((storage-of-A), o+s₀i₀, (s₁, ...))
</p></blockquote>

<p>Note that we can iterate over these items by simply bumping the pointer o+s₀i₀. This means that iterating over (k&gt;0)-cells doesn&rsquo;t cost any  more than iterating over 0-cells (see <a href="#Cell-iteration">Cell iteration</a>).
</p>
<hr>
<span id="Drag-along-and-beating"></span><div class="header">
<p>
Next: <a href="#Why-C_002b_002b" accesskey="n" rel="next">Why C++</a>, Previous: <a href="#Rank-polymorphism" accesskey="p" rel="prev">Rank polymorphism</a>, Up: <a href="#Overview" accesskey="u" rel="up">Overview</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Drag-along-and-beating-1"></span><h3 class="section">1.2 Drag along and beating</h3>

<p>These two fundamental array optimizations are described in [<a href="#Sources">Abr70</a>]
.
</p>
<p><em>Drag-along</em> is the process that delays evaluation of array operations. Expression templates can be seen as an implementation of drag-along. Drag-along isn&rsquo;t an optimization in and of itself; it simply preserves the necessary information up to the point where the expression can be executed efficiently.
</p>
<p><em>Beating</em> is the implementation of certain array operations on the array <a href="#Containers-and-views">view</a> descriptor instead of on the array contents. For example, if <code>A</code> is a 1-array, one can implement <a href="#x_002dreverse"><code>reverse(A, 0)</code></a> by negating the <a href="#x_002dstrides">stride</a> and moving the offset to the other end of the array, without having to move any elements. More generally, beating applies to any function-of-indices (generator) that can take the place of an array in an array expression. For instance, an expression such as <a href="#x_002diota"><code>1+iota(3, 0)</code></a> can be beaten into <code>iota(3, 1)</code>, and this can enable further optimizations.
</p>
<hr>
<span id="Why-C_002b_002b"></span><div class="header">
<p>
Next: <a href="#Guidelines" accesskey="n" rel="next">Guidelines</a>, Previous: <a href="#Drag-along-and-beating" accesskey="p" rel="prev">Drag along and beating</a>, Up: <a href="#Overview" accesskey="u" rel="up">Overview</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Why-C_002b_002b-1"></span><h3 class="section">1.3 Why C++</h3>

<p>Of course the main reason is that (this being a personal project) I&rsquo;m more familiar with C++ than with other languages to which the following might apply.
</p>
<p>C++ supports the low level control that is necessary for interoperation with external libraries and languages, but still has the abstraction power to create the features we want even though the language has no native support for most of them.
</p>
<span id="index-APL"></span>
<span id="index-J"></span>
<p>The classic array languages, APL [<a href="#Sources">FI73</a>]
 and J [<a href="#Sources">Ric08</a>]
, have array support baked in. The same is true for other languages with array facilities such as Fortran or Octave/Matlab. Array libraries for general purpose languages usually depend heavily on C extensions. In Numpy&rsquo;s case [<a href="#Sources">num17</a>]
 this is both for reasons of flexibility (e.g. to obtain predictable memory layout and machine types) and of performance.
</p>
<p>On the other extreme, an array library for C would be hampered by the limited means of abstraction in the language (no polymorphism, no metaprogramming, etc.) so the natural choice of C programmers is to resort to code generators, which eventually turn into new languages.
</p>
<p>In C++, a library is enough.
</p>
<hr>
<span id="Guidelines"></span><div class="header">
<p>
Next: <a href="#Other-libraries" accesskey="n" rel="next">Other libraries</a>, Previous: <a href="#Why-C_002b_002b" accesskey="p" rel="prev">Why C++</a>, Up: <a href="#Overview" accesskey="u" rel="up">Overview</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Guidelines-1"></span><h3 class="section">1.4 Guidelines</h3>

<p><code>ra::</code> attempts to be general, consistent, and transparent.
</p>
<p>Generality is achieved by removing arbitrary restrictions and by adopting the rank extension mechanism of J. <code>ra::</code> supports array operations with an arbitrary number of arguments. Any of the arguments in an array expression can be read from or written to. Arrays or array expressions can be of any rank. Slicing operations work for subscripts of any rank, as in APL. You can use your own types as array elements.
</p>
<p>Consistency is achieved by having a clear set of concepts and having the realizations of those concepts adhere to the concept as closely as possible. <code>ra::</code> offers a few different types of views and containers, but it should be possible to use them interchangeably whenever the properties that justify their existence are not involved. When this isn&rsquo;t possible, it&rsquo;s a bug. For example, it used to be the case that you couldn&rsquo;t create a higher rank iterator on a <code>SmallView</code>, even though you could do it on a <code>View</code>; this was a bug.
</p>
<p>Sometimes consistency requires a choice. For example, given array views A and B, <code>A=B</code> copies the contents of view B into view A. To change view A instead (to treat A as a pointer) would be the default meaning of A=B for C++ types, and result in better consistency with the rest of the language, but I have decided that having consistency between views and containers (which ‘are’ their contents in a sense that views aren&rsquo;t) is more important.
</p>
<p>Transparency is achieved by avoiding opaque types. An array view consists of a pointer and a list of strides and I see no point in hiding that. Manipulating the strides directly is often useful. A container consists of storage and a view and that isn&rsquo;t hidden either. Some of the types have an obscure implementation but I consider that a defect. Ideally you should be able to rewrite expressions on the fly, or plug in your own traversal methods or storage handling.
</p>
<p>That isn&rsquo;t to mean that you need to be in command of a lot of internal detail to be able to use the library. I hope to have provided a high level interface to most operations and a reasonably sweet syntax. However, transparency is critical to achieve interoperation with external libraries and languages. When you need to, you&rsquo;ll be able to guarantee that an array is stored by compact columns or that the real parts are interleaved with the imaginary parts.
</p>
<hr>
<span id="Other-libraries"></span><div class="header">
<p>
Previous: <a href="#Guidelines" accesskey="p" rel="prev">Guidelines</a>, Up: <a href="#Overview" accesskey="u" rel="up">Overview</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Other-array-libraries"></span><h3 class="section">1.5 Other array libraries</h3>

<p>Here I try to list the C++ array libraries that I know of, or libraries that I think deserve a mention for the way they deal with arrays. It is not an extensive review, since I have only used a few of these libraries myself. Please follow the links if you want to be properly informed.
</p>
<p>Since the C++ standard library doesn&rsquo;t offer a standard multidimensional array type, some libraries for specific tasks (linear algebra operations, finite elements, optimization) offer an accessory array library, which may be more or less general. Other libraries have generic array interfaces without needing to provide an array type. FFTW is a good example, maybe because it isn&rsquo;t C++!
</p>
<span id="Standard-C_002b_002b"></span><h4 class="subsection">1.5.1 Standard C++</h4>

<p>The C++ language offers multidimensional arrays as a legacy feature from C, e.g. <code>int a[3][4]</code>. These decay to pointers when you do nearly anything with them, don&rsquo;t know their own sizes or rank at runtime, and are generally too limited.
</p>
<p>The C++ standard library also offers a number of contiguous storage containers that can be used as 1-arrays: <code>&lt;array&gt;</code>, <code>&lt;vector&gt;</code> and <code>&lt;valarray&gt;</code>. Neither supports higher ranks out of the box, but <code>&lt;valarray&gt;</code> offers array operations for 1-arrays. <code>ra::</code> makes use of <code>&lt;array&gt;</code> and <code>&lt;vector&gt;</code> for storage and bootstrapping.
</p>
<p><code>ra::</code> accepts built-in arrays and standard library types as array objects (see <a href="#Compatibility">Compatibility</a>).
</p>
<span id="Blitz_002b_002b"></span><h4 class="subsection">1.5.2 Blitz++</h4>
<span id="index-Blitz_002b_002b-1"></span>
<p>Blitz++ [<a href="#Sources">bli17</a>]
 pioneered the use of expression templates in C++. It supported higher rank arrays, as high as it was practical in C++98, but not dynamic rank. It also supported small arrays with compile time sizes (<code>Tiny</code>), and convenience features such as Fortran-order constructors and arbitrary lower bounds for the array indices (both of which <code>ra::</code> chooses not to support). It placed a strong emphasis on performance, with array traversal methods such as blocking, space filling curves, etc.
</p>
<p>To date it remains, I believe, one of the most general array libraries for C++. However, the implementation had to fight the limitations of C++98, and it offered no general rank extension mechanism.
</p>
<p>One important difference between Blitz++ and <code>ra::</code> is that Blitz++&rsquo;s arrays were reference counted. <code>ra::</code> doesn&rsquo;t do any memory management on its own: the default container types are explicitly values (data-owning) or views. You can select your own storage for the data-owning objects, including reference-counted storage (<code>ra::</code> declares a type using <code>std::shared_ptr</code>), but this is not the default.
</p>
<span id="Other-C_002b_002b-libraries"></span><h4 class="subsection">1.5.3 Other C++ libraries</h4>

<p>I guess this is important enough!
</p>
<span id="Other-languages"></span><h4 class="subsection">1.5.4 Other languages</h4>

<p>TODO Maybe review other languages, at least the big ones (Fortran/APL/J/Matlab/Numpy).
</p>
<hr>
<span id="Usage"></span><div class="header">
<p>
Next: <a href="#Extras" accesskey="n" rel="next">Extras</a>, Previous: <a href="#Overview" accesskey="p" rel="prev">Overview</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Usage-1"></span><h2 class="chapter">2 Usage</h2>

<p>This is an extended exposition of the features of <code>ra::</code> and is probably best read in order. For details on specific functions or types, please see <a href="#Reference">Reference</a>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Using-the-library" accesskey="1">Using the library</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"><code>ra::</code> is a header-only library.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Containers-and-views" accesskey="2">Containers and views</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Data objects.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Array-operations" accesskey="3">Array operations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Building and traversing expressions.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Rank-extension" accesskey="4">Rank extension</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">How array operands are matched.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Cell-iteration" accesskey="5">Cell iteration</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">At any rank.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Slicing" accesskey="6">Slicing</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Subscripting is a special operation.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Special-objects" accesskey="7">Special objects</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Not arrays, yet arrays.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-rank-conjunction" accesskey="8">The rank conjunction</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">J comes to C++.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Compatibility" accesskey="9">Compatibility</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">With the STL and other libraries.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Extension">Extension</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Using your own types and more.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Functions">Functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Ready to go.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Error-handling">Error handling</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">What to check and what to do.
</td></tr>
</table>

<hr>
<span id="Using-the-library"></span><div class="header">
<p>
Next: <a href="#Containers-and-views" accesskey="n" rel="next">Containers and views</a>, Up: <a href="#Usage" accesskey="u" rel="up">Usage</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Using-ra_003a_003a"></span><h3 class="section">2.1 Using <code>ra::</code></h3>

<p><code>ra::</code> is a header only library with no dependencies, so you just need to place the &lsquo;<samp>ra/</samp>&rsquo; folder somewhere in your include path and add <code>#include &quot;ra/operators.H&quot;</code> and <code>&quot;ra/io.H&quot;</code> at the top of your sources.
</p>
<p>A compiler with C++17 support is required. At the time of writing this means <b>gcc 8.0</b> or <b>clang-5.0</b> with <samp>-std=c++17</samp>. Check the top README.md for more up-to-date information.
</p>
<p>Here is a minimal program<a id="DOCF3" href="#FOOT3"><sup>3</sup></a>:
</p>
<div class="example">
<pre class="verbatim">#include &quot;ra/operators.H&quot;
#include &quot;ra/io.H&quot;
#include &lt;iostream&gt;

int main()
{
    ra::Big&lt;char, 2&gt; A({2, 5}, &quot;helloworld&quot;);
    std::cout &lt;&lt; ra::noshape &lt;&lt; format_array(transpose&lt;1, 0&gt;(A), &quot;|&quot;) &lt;&lt; std::endl;
}
</pre><pre class="example">-| h|w
   e|o
   l|r
   l|l
   d|d
</pre></div>

<p>You may want to <code>#include &quot;ra/real.H&quot;</code> and <code>&quot;ra/complex.H&quot;</code>. These put some functions in the global namespace that make it easier to work on built-in scalar types or array expressions indistinctly. They are not required for the rest of the library to function.
</p>
<span id="index-container"></span>
<hr>
<span id="Containers-and-views"></span><div class="header">
<p>
Next: <a href="#Array-operations" accesskey="n" rel="next">Array operations</a>, Previous: <a href="#Using-the-library" accesskey="p" rel="prev">Using the library</a>, Up: <a href="#Usage" accesskey="u" rel="up">Usage</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Containers-and-views-1"></span><h3 class="section">2.2 Containers and views</h3>

<p><code>ra::</code> offers two kinds of data objects. The first kind, the <em>container</em>, owns its data. Creating a container requires memory and destroying it causes that memory to be freed.
</p>
<p>There are three kinds of containers: static size, static rank/dynamic size, and dynamic rank. Here static means ‘compile time constant’ while dynamic means ‘run time constant’. Some dynamic size arrays can be resized but dynamic rank arrays cannot normally have their rank changed. Instead, you create a new container or view with the rank you want.
</p>
<p>For example:
</p>
<div class="example">
<pre class="verbatim">{
    ra::Small&lt;double, 2, 3&gt; a(0.);     // a static size 2x3 array
    ra::Big&lt;double, 2&gt; b({2, 3}, 0.);  // a dynamic size 2x3 array
    ra::Big&lt;double&gt; c({2, 3}, 0.);     // a dynamic rank 2x3 array
    // a, b, c destroyed at end of scope
}
</pre></div>

<p>The main reason to have all these different types is performance; the compiler can do a better job when it knows the size or the rank of the array. Also, the sizes of a static size array do not need to be stored in memory, so when you have thousands of small arrays it pays off to use the static size types. Static size or static rank arrays are also safer to use; sometimes <code>ra::</code> will be able to detect errors in the sizes or ranks of array operands at compile time, if the appropriate types are used.
</p>
<p>Container constructors come in two forms. The first form takes a single argument which is copied into the new container. This argument provides shape information if the container type requires it.<a id="DOCF4" href="#FOOT4"><sup>4</sup></a>
</p>
<div class="example">
<pre class="verbatim">using ra::Small, ra::Big;
Small&lt;int, 2, 2&gt; a = {{1, 2}, {3, 4}};  // explicit contents
Big&lt;int, 2&gt; a1 = {{1, 2}, {3, 4}};      // explicit contents
Small&lt;int, 2, 2&gt; a2 = {{1, 2}};         // error: bad size
Small&lt;int, 2, 2&gt; b = 7;                 // 7 is copied into b
Small&lt;int, 2, 2&gt; c = a;                 // the contents of a are copied into c
Big&lt;int&gt; d = a;                         // d takes the shape of a and a is copied into d
Big&lt;int&gt; e = 0;                         // e is a 0-array with one element f()==0.
</pre></div>

<p>The second form takes two arguments, one giving the shape, the second the contents.
</p>
<span id="index-none"></span>
<div class="example">
<pre class="verbatim">ra::Big&lt;double, 2&gt; a({2, 3}, 1.);     // a has size 2x3 and be filled with 1.
ra::Big&lt;double&gt; b({2, 3}, ra::none);  // b has size 2x3 and contents don't matter
ra::Big&lt;double&gt; c({2, 3}, a);         // c has size 2x3 and a is copied into c
</pre></div>

<p>The last example may result in an error if the shape of <code>a</code> and (2,&nbsp;<!-- /@w -->3) don&rsquo;t match. Here the shape of <code>1.</code> [which is ()] matches (2,&nbsp;<!-- /@w -->3) by a mechanism of rank extension (see <a href="#Rank-extension">Rank extension</a>). The special value <code>ra::none</code> can be used to request <a href="https://en.cppreference.com/w/cpp/language/default_initialization">default initialization</a> of the container&rsquo;s elements.
</p>
<p>When the content argument is a pointer or a 1D brace list, it&rsquo;s handled especially, not for shape<a id="DOCF5" href="#FOOT5"><sup>5</sup></a>, but only as the (row-major) ravel of the content. The pointer constructor is unsafe —use at your own risk!<a id="DOCF6" href="#FOOT6"><sup>6</sup></a>
</p>
<span id="index-order_002c-column_002dmajor"></span>
<div class="example">
<pre class="verbatim">Small&lt;int, 2, 2&gt; aa = {1, 2, 3, 4}; // ravel of the content

ra::Big&lt;double, 2&gt; a({2, 3}, {1, 2, 3, 4, 5, 6}); // same as a = {{1, 2, 3}, {4, 5, 6}}
</pre></div>

<div class="example">
<pre class="verbatim">double bx[6] = {1, 2, 3, 4, 5, 6}
ra::Big&lt;double, 2&gt; b({3, 2}, bx); // {{1, 2}, {3, 4}, {5, 6}}

double cx[4] = {1, 2, 3, 4}
ra::Big&lt;double, 2&gt; c({3, 2}, cx); // *** WHO NOSE ***
</pre></div>

<div class="example">
<pre class="verbatim">using sizes = mp::int_list&lt;2, 3&gt;;
using strides = mp::int_list&lt;1, 2&gt;;
ra::SmallArray&lt;double, sizes, strides&gt; a {{1, 2, 3}, {4, 5, 6}}; // stored column-major: 1 4 2 5 3 6
</pre></div>

<p>These are compile time errors:
</p>
<div class="example">
<pre class="verbatim">Big&lt;int, 2&gt; b = {1, 2, 3, 4};           // error: shape cannot be deduced from ravel
Small&lt;int, 2, 2&gt; b = {1, 2, 3, 4 5};    // error: bad size
Small&lt;int, 2, 2&gt; b = {1, 2, 3};         // error: bad size
</pre></div>

<span id="x_002dscalar_002dchar_002dstar"></span><p>Sometimes the pointer constructor gets in the way (see <a href="#x_002dscalar"><code>scalar</code></a>): </p>
<div class="example">
<pre class="verbatim">ra::Big&lt;char const *, 1&gt; A({3}, &quot;hello&quot;); // error: try to convert char to char const *
ra::Big&lt;char const *, 1&gt; A({3}, ra::scalar(&quot;hello&quot;)); // ok, &quot;hello&quot; is a single item
cout &lt;&lt; ra::noshape &lt;&lt; format_array(A, &quot;|&quot;) &lt;&lt; endl;
</pre><pre class="example">-| hello|hello|hello
</pre></div>

<span id="index-view"></span>
<p>A <em>view</em> is similar to a container in that it points to actual data in memory. However, the view doesn&rsquo;t own that data and destroying the view won&rsquo;t affect it. For example:
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;double&gt; c({2, 3}, 0.);     // a dynamic rank 2x3 array
{
    auto c1 = c(1);                // the second row of array c
    // c1 is destroyed here
}
cout &lt;&lt; c(1, 1) &lt;&lt; endl;           // ok
</pre></div>

<p>The data accessed through a view is the data of the ‘root’ container, so modifying the first will be reflected in the latter.
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;double&gt; c({2, 3}, 0.);
auto c1 = c(1);
c1(2) = 9.;                        // c(1, 2) = 9.
</pre></div>

<p>Just as for containers, there are separate types of views depending on whether the size is known at compile time, the rank is known at compile time but the size is not, or neither the size nor the rank are known at compile time. <code>ra::</code> has functions to create the most common kinds of views:
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;double&gt; c {{1, 2, 3}, {4, 5, 6}};
auto ct = transpose&lt;1, 0&gt;(c); // {{1, 4}, {2, 5}, {3, 6}}
auto cr = reverse(c, 0); // {{4, 5, 6}, {1, 2, 3}}
</pre></div>

<p>However, views can point to anywhere in memory and that memory doesn&rsquo;t have to belong to an <code>ra::</code> container. For example:
</p>
<div class="example">
<pre class="verbatim">int raw[6] = {1, 2, 3, 4, 5, 6};
ra::View&lt;int&gt; v1({{2, 3}, {3, 1}}, raw); // view with sizes {2, 3} strides {3, 1}
ra::View&lt;int&gt; v2({2, 3}, raw);           // same, default C (row-major) strides
</pre></div>

<p>Containers can be treated as views of the same ‘dynamicness’. If you declare a function
</p>
<div class="example">
<pre class="verbatim">void f(ra::View&lt;int, 3&gt; &amp; v);
</pre></div>

<p>you may pass it an object of type <code>ra::Big&lt;int, 3&gt;</code>.
</p>

<hr>
<span id="Array-operations"></span><div class="header">
<p>
Next: <a href="#Rank-extension" accesskey="n" rel="next">Rank extension</a>, Previous: <a href="#Containers-and-views" accesskey="p" rel="prev">Containers and views</a>, Up: <a href="#Usage" accesskey="u" rel="up">Usage</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Array-operations-1"></span><h3 class="section">2.3 Array operations</h3>

<p>To apply an operation to each element of an array, use the function <code>for_each</code>. The array is traversed in an order that is decided by the library.
</p>
<div class="example">
<pre class="verbatim">ra::Small&lt;double, 2, 3&gt; a = {{1, 2, 3}, {4, 5, 6}};
double s = 0.;
for_each([&amp;s](auto &amp;&amp; a) { s+=a; }, a);
</pre><pre class="example">&rArr; s = 21.
</pre></div>

<p>To construct an array expression but stop short of traversing it, use the function <code>map</code>. The expression will be traversed when it is assigned to a view, printed out, etc.
</p>
<div class="example">
<pre class="verbatim">using T = ra::Small&lt;double, 2, 2&gt;;
T a = {{1, 2}, {3, 4}};
T b = {{10, 20}, {30, 40}};
T c = map([](auto &amp;&amp; a, auto &amp;&amp; b) { return a+b; }, a, b); // (1)
</pre><pre class="example">&rArr; c = {{11, 22}, {33, 44}}
</pre></div>

<p>Expressions may take any number of arguments and be nested arbitrarily.
</p>
<div class="example">
<pre class="verbatim">T d = 0;
for_each([](auto &amp;&amp; a, auto &amp;&amp; b, auto &amp;&amp; d) { d = a+b; },
         a, b, d); // same as (1)
for_each([](auto &amp;&amp; ab, auto &amp;&amp; d) { d = ab; },
         map([](auto &amp;&amp; a, auto &amp;&amp; b) { return a+b; },
             a, b),
         d); // same as (1)
</pre></div>

<p>The operator of an expression may return a reference and you may assign to an expression in that case. <code>ra::</code> will complain if the expression is somehow not assignable.
</p>
<div class="example">
<pre class="verbatim">T d = 0;
map([](auto &amp; d) -&gt; decltype(auto) { return d; }, d) // just pass d along
  = map([](auto &amp;&amp; a, auto &amp;&amp; b) { return a+b; }, a, b); // same as (1)
</pre></div>

<p><code>ra::</code> defines many shortcuts for common array operations. You can of course just do:
</p>
<div class="example">
<pre class="verbatim">T c = a+b; // same as (1)
</pre></div>

<hr>
<span id="Rank-extension"></span><div class="header">
<p>
Next: <a href="#Cell-iteration" accesskey="n" rel="next">Cell iteration</a>, Previous: <a href="#Array-operations" accesskey="p" rel="prev">Array operations</a>, Up: <a href="#Usage" accesskey="u" rel="up">Usage</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Rank-extension-1"></span><h3 class="section">2.4 Rank extension</h3>

<p>Rank extension is the mechanism that allows <code>R+S</code> to be defined even when <code>R</code>, <code>S</code> may have different ranks. The idea is an interpolation of the following basic cases.
</p>
<p>Suppose first that <code>R</code> and <code>S</code> have the same rank. We require that the shapes be the same. Then the shape of <code>R+S</code> will be the same as the shape of either <code>R</code> or <code>S</code> and the elements of <code>R+S</code> will be
</p>
<blockquote>
<p><code>(R+S)(i₀ i₁ ... i₍ᵣ₋₁₎) = R(i₀ i₁ ... i₍ᵣ₋₁₎) + S(i₀ i₁ ... i₍ᵣ₋₁₎)</code>
</p></blockquote>

<p>where <code>r</code> is the rank of <code>R</code>.
</p>
<p>Now suppose that <code>S</code> has rank 0. The shape of <code>R+S</code> is the same as the shape of <code>R</code> and the elements of <code>R+S</code> will be
</p>
<blockquote>
<p><code>(R+S)(i₀ i₁ ... i₍ᵣ₋₁₎) = R(i₀ i₁ ... i₍ᵣ₋₁₎) + S()</code>.
</p></blockquote>

<p>The two rules above are supported by all primitive array languages, e.g. Matlab [<a href="#Sources">Mat</a>]
. But suppose that <code>S</code> has rank <code>s</code>, where <code>0&lt;s&lt;r</code>. Looking at the expressions above, it seems natural to define <code>R+S</code> by
</p>
<blockquote>
<p><code>(R+S)(i₀ i₁ ... i₍ₛ₋₁₎ ... i₍ᵣ₋₁₎) = R(i₀ i₁ ... i₍ₛ₋₁₎ ... i₍ᵣ₋₁₎) + S(i₀ i₁ ... i₍ₛ₋₁₎)</code>.
</p></blockquote>

<p>That is, after we run out of indices in <code>S</code>, we simply repeat the elements. We have aligned the shapes so:
</p>
<blockquote>
<pre class="verbatim">[n₀ n₁ ... n₍ₛ₋₁₎ ... n₍ᵣ₋₁₎]
[n₀ n₁ ... n₍ₛ₋₁₎]
</pre></blockquote>

<span id="index-shape-agreement_002c-prefix"></span>
<span id="index-shape-agreement_002c-suffix"></span>
<span id="index-Numpy"></span>
<p>This rank extension rule is used by the J language [<a href="#Sources">J S</a>]
 and is known as <em>prefix agreement</em>. The opposite rule of <em>suffix agreement</em> is used, for example, in Numpy [<a href="#Sources">num17</a>]
<a id="DOCF7" href="#FOOT7"><sup>7</sup></a>.
</p>
<p>As you can verify, the prefix agreement rule is distributive. Therefore it can be applied to nested expressions or to expressions with any number of arguments. It is applied systematically throughout <code>ra::</code>, even in assignments. For example,
</p>
<div class="example">
<pre class="verbatim">ra::Small&lt;int, 3&gt; x {3, 5, 9};
ra::Small&lt;int, 3, 2&gt; a = x; // assign x(i) to each a(i, j)
</pre><pre class="example">&rArr; a = {{3, 3}, {5, 5}, {9, 9}}
</pre></div>

<div class="example">
<pre class="verbatim">ra::Small&lt;int, 3&gt; x(0.);
ra::Small&lt;int, 3, 2&gt; a = {{1, 2}, {3, 4}, {5, 6}};
x += a; // sum the rows of a
</pre><pre class="example">&rArr; x = {3, 7, 11}
</pre></div>

<div class="example">
<pre class="verbatim">ra::Big&lt;double, 3&gt; a({5, 3, 3}, ra::_0);
ra::Big&lt;double, 1&gt; b({5}, 0.);
b += transpose&lt;0, 1, 1&gt;(a); // b(i) = ∑ⱼ a(i, j, j)
</pre><pre class="example">&rArr; b = {0, 3, 6, 9, 12}
</pre></div>

<p>An weakness of prefix agreement is that the axes you want to match aren&rsquo;t always the prefix axes. <a href="#x_002dtranspose">Transposing</a> the axes before extension is a possible workaround. For a more general form of rank extension, see <a href="#The-rank-conjunction">The rank conjunction</a>.
</p>
<span id="index-Numpy-1"></span>
<span id="index-broadcasting_002c-singleton"></span>
<p>Other languages have a feature similar to rank extension called ‘broadcasting’. For example, in the way it&rsquo;s implemented in Numpy [<a href="#Sources">num17</a>]
, an array of shape [A B 1 D] will match an array of shape [A B C D]. The process of broadcasting consists in inserting so-called ‘singleton dimensions’ (axes with size one) to align the axes that one wishes to match. This is more general than prefix agreement, because any axes can be matched. You can think of prefix agreement as the case where all the singleton dimensions are added to the end of the shape.
</p>
<p>Singleton broadcasting still isn&rsquo;t entirely general, since it doesn&rsquo;t handle transposition. Another drawback is that it muddles the distinction between a scalar and a vector of size 1. Sometimes, an axis of size 1 is no more than that, and if 2!=3 is a size error, it isn&rsquo;t obvious why 1!=2 shouldn&rsquo;t be.
</p>
<hr>
<span id="Cell-iteration"></span><div class="header">
<p>
Next: <a href="#Slicing" accesskey="n" rel="next">Slicing</a>, Previous: <a href="#Rank-extension" accesskey="p" rel="prev">Rank extension</a>, Up: <a href="#Usage" accesskey="u" rel="up">Usage</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Cell-iteration-1"></span><h3 class="section">2.5 Cell iteration</h3>

<p><code>map</code> and <code>for_each</code> apply their operators to each element of their arguments; in other words, to the 0-cells of the arguments. But it is possible to specify directly the rank of the cells that one iterates over:
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;double, 3&gt; a({5, 4, 3}, ra::_0);
for_each([](auto &amp;&amp; b) { /* b has shape (5 4 3) */ }, iter&lt;3&gt;(a));
for_each([](auto &amp;&amp; b) { /* b has shape (4 3) */ }, iter&lt;2&gt;(a));
for_each([](auto &amp;&amp; b) { /* b has shape (3) */ }, iter&lt;1&gt;(a));
for_each([](auto &amp;&amp; b) { /* b has shape () */ }, iter&lt;0&gt;(a)); // elements
for_each([](auto &amp;&amp; b) { /* b has shape () */ }, a); // same as iter&lt;0&gt;(a); default
</pre></div>

<p>One may specify the <em>frame</em> rank instead:
</p>
<div class="example">
<pre class="verbatim">for_each([](auto &amp;&amp; b) { /* b has shape () */ }, iter&lt;-3&gt;(a)); // same as iter&lt;0&gt;(a)
for_each([](auto &amp;&amp; b) { /* b has shape (3) */ }, iter&lt;-2&gt;(a)); // same as iter&lt;1&gt;(a)
for_each([](auto &amp;&amp; b) { /* b has shape (4 3) */ }, iter&lt;-1&gt;(a)); // same as iter&lt;2&gt;(a)
</pre></div>

<p>In this way it is possible to match shapes in various ways. Compare
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;double, 2&gt; a = {{1, 2, 3}, {4, 5, 6}};
ra::Big&lt;double, 1&gt; b = {10, 20};
ra::Big&lt;double, 2&gt; c = a * b; // multiply (each item of a) by (each item of b)
</pre><pre class="example">&rArr; a = {{10, 20, 30}, {80, 100, 120}}
</pre></div>

<p>with
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;double, 2&gt; a = {{1, 2, 3}, {4, 5, 6}};
ra::Big&lt;double, 1&gt; b = {10, 20, 30};
ra::Big&lt;double, 2&gt; c({2, 3}, 0.);
iter&lt;1&gt;(c) = iter&lt;1&gt;(a) * iter&lt;1&gt;(b); // multiply (each item of a) by (b)
</pre><pre class="example">&rArr; a = {{10, 40, 90}, {40, 100, 180}}
</pre></div>

<p>Note that in this case we cannot construct <code>c</code> directly from <code>iter&lt;1&gt;(a) * iter&lt;1&gt;(b)</code>, since the constructor for <code>ra::Big</code> matches its argument using (the equivalent of) <code>iter&lt;0&gt;(*this)</code>. See <a href="#x_002diter"><code>iter</code></a> for more examples.
</p>
<p>Cell iteration is appropriate when the operations take naturally operands of rank &gt; 0; for instance, the operation ‘determinant of a matrix’ is naturally of rank 2. When the operation is of rank 0, such as <code>*</code> above, there may be faster ways to rearrange shapes for matching (see <a href="#The-rank-conjunction">The rank conjunction</a>).
</p>
<p>FIXME More examples.
</p>
<hr>
<span id="Slicing"></span><div class="header">
<p>
Next: <a href="#Special-objects" accesskey="n" rel="next">Special objects</a>, Previous: <a href="#Cell-iteration" accesskey="p" rel="prev">Cell iteration</a>, Up: <a href="#Usage" accesskey="u" rel="up">Usage</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Slicing-1"></span><h3 class="section">2.6 Slicing</h3>

<p>Slicing is an array extension of the subscripting operation. However, tradition and convenience have given it a special status in most array languages, together with some peculiar semantics that <code>ra::</code> supports.
</p>
<p>The form of the scripting operator <code>A(i₀, i₁, ...)</code> makes it plain that <code>A</code> is a function of <code>rank(A)</code> integer arguments. An array extension is immediately available through <code>map</code>. For example:
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;double, 1&gt; a = {1., 2., 3., 4.};
ra::Big&lt;int, 1&gt; i = {1, 3};
map(a, i) = 77.;
</pre><pre class="example">&rArr; a = {1., 77., 3, 77.}
</pre></div>

<p>Just as with any use of <code>map</code>, array arguments are subject to the prefix agreement rule.
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;double, 2&gt; a({2, 2}, {1., 2., 3., 4.});
ra::Big&lt;int, 1&gt; i = {1, 0};
ra::Big&lt;double, 1&gt; b = map(a, i, 0);
</pre><pre class="example">&rArr; b = {3., 1.} // {a(1, 0), a(0, 0)}
</pre></div>

<div class="example">
<pre class="verbatim">ra::Big&lt;int, 1&gt; j = {0, 1};
b = map(a, i, j);
</pre><pre class="example">&rArr; b = {3., 2.} // {a(1, 0), a(0, 1)}
</pre></div>

<p>The latter is a form of sparse subscripting.
</p>
<p>Most array operations (e.g. <code>+</code>) are defined through <code>map</code> in this way. For example, <code>A+B+C</code> is defined as <code>map(+, A, B, C)</code> (or the equivalent <code>map(+, map(+, A, B), C)</code>). Not so for the subscripting operation:
</p>

<div class="example">
<pre class="verbatim">ra::Big&lt;double, 2&gt; A {{1., 2.}, {3., 4.}};
ra::Big&lt;int, 1&gt; i = {1, 0};
ra::Big&lt;int, 1&gt; j = {0, 1};
// {{A(i₀, j₀), A(i₀, j₁)}, {A(i₁, j₀), A(i₁, j₁)}}
ra::Big&lt;double, 2&gt; b = A(i, j);
</pre><pre class="example">&rArr; b = {{3., 4.}, {1., 2.}}
</pre></div>

<p><code>A(i, j, ...)</code> is defined as the <em>outer product</em> of the indices <code>(i, j, ...)</code> with operator <code>A</code>, because this operation sees much more use in practice than <code>map(A, i, j ...)</code>.
</p>
<p>Besides, when the subscripts <code>i, j, ...</code> are scalars or <em>linear ranges</em> (integer sequences of the form <code>(o, o+s, ..., o+s*(n-1))</code>, the subscripting can be performed inmediately at constant cost and without needing to construct an expression object. This optimization is called <a href="#Drag-along-and-beating"><em>beating</em></a>.
</p>
<p><code>ra::</code> isn&rsquo;t smart enough to know when an arbitrary expression might be a linear range, so the following special objects are provided:
</p>
<span id="x_002diota"></span><dl>
<dt id="index-iota">Special&nbsp;object<!-- /@w -->: <strong>iota</strong> <em>count [start:0 [step:1]]</em></dt>
<dd><p>Create a linear range <code>start, start+step, ... start+step*(count-1)</code>.
</p></dd></dl>

<p>This can used anywhere an array expression is expected.
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;int, 1&gt; a = ra::iota(4, 3 -2);
</pre><pre class="example">&rArr; a = {3, 1, -1, -3}
</pre></div>

<p>Here, <code>b</code> and <code>c</code> are <code>View</code>s (see <a href="#Containers-and-views">Containers and views</a>).
</p><div class="example">
<pre class="verbatim">ra::Big&lt;int, 1&gt; a = {1, 2, 3, 4, 5, 6};
auto b = a(iota(3));
auto c = a(iota(3, 3));
</pre><pre class="example">&rArr; a = {1, 2, 3}
&rArr; a = {4, 5, 6}
</pre></div>

<dl>
<dt id="index-all">Special&nbsp;object<!-- /@w -->: <strong>all</strong></dt>
<dd><p>Create a linear range <code>0, 1, ... (nᵢ-1)</code> when used as a subscript for the <code>i</code>-th argument of a subscripting expression.
</p></dd></dl>

<p>This object cannot stand alone as an array expression. All the examples below result in <code>View</code> objects:
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;int, 2&gt; a({3, 2}, {1, 2, 3, 4, 5, 6});
auto b = a(ra::all, ra::all); // (1) a view of the whole of a
auto c = a(iota(3), iota(2)); // same as (1)
auto d = a(iota(3), ra::all); // same as (1)
auto e = a(ra:all, iota(2)); // same as (1)
auto f = a(0, ra::all); // first row of a
auto g = a(ra::all, 1); // second column of a
</pre></div>

<p><code>all</code> is a special case (<code>dots&lt;1&gt;</code>) of the more general object <code>dots</code>.
</p>
<dl>
<dt id="index-dots_003cn_003e">Special&nbsp;object<!-- /@w -->: <strong>dots&lt;n&gt;</strong></dt>
<dd><p>Equivalent to as many instances of <code>ra::all</code> as indicated by <code>n</code>, which must not be negative. Each instance takes the place of one argument to the subscripting operation.
</p></dd></dl>

<p>This object cannot stand alone as an array expression. All the examples below result in <code>View</code> objects:
</p>
<div class="example">
<pre class="verbatim">auto h = a(ra::all, ra::all); // same as (1)
auto i = a(ra::all, ra::dots&lt;1&gt;); // same as (1)
auto j = a(ra::dots&lt;2&gt;); // same as (1)
auto k = a(ra::dots&lt;0&gt;, ra::dots&lt;2&gt;); // same as (1)
auto l = a(0, ra::dots&lt;1&gt;); // first row of a
auto m = a(ra::dots&lt;1&gt;, 1); // second column of a
</pre></div>

<p>This is useful when writing rank-generic code, see <code>examples/maxwell.C</code> in the distribution for an example.
</p>
<dl>
<dt id="index-newaxis_003cn_003e">Special&nbsp;object<!-- /@w -->: <strong>newaxis&lt;n&gt;</strong></dt>
<dd><p>Inserts <code>n</code> new axes at the subscript position. <code>n</code> must not be negative. The new axes have size 1 and stride 0.
</p></dd></dl>

<p>This object cannot stand alone as an array expression. All the examples below result in <code>View</code> objects:
</p>
<div class="example">
<pre class="verbatim">auto h = a(newaxis&lt;0&gt;); // same as (1)
auto i = a(newaxis&lt;1&gt;); // same contents as ra::Big&lt;int, 2&gt; a({1, 3, 2}, {1, 2, 3, 4, 5, 6})
</pre></div>

<span id="index-broadcasting_002c-singleton-1"></span>
<p><code>newaxis&lt;n&gt;</code> main use is to prepare arguments for broadcasting. However, since argument agreement in <code>ra::</code> requires exact size match on all dimensions, this isn&rsquo;t currently as useful as in e.g. Numpy where dimensions of size 1 match dimensions of any other size. A more flexible syntax <code>newaxis(n0, n1...)</code> to insert axes of arbitrary sizes may be implemented in the future.
</p>
<p>In addition to the special objects listed above, you can also omit any trailing <code>ra::all</code> subscripts. For example:
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;int, 3&gt; a({2, 2, 2}, {1, 2, 3, 4, 5, 6, 7, 8});
auto a0 = a(0); // same as a(0, ra::all, ra::all)
auto a10 = a(1, 0); // same as a(1, 0, ra::all)
</pre><pre class="example">&rArr; a0 = {{1, 2}, {3, 4}}
&rArr; a10 = {5, 6}
</pre></div>

<p>This supports the notion (see <a href="#Rank-polymorphism">Rank polymorphism</a>) that a 3-array is also an 2-array where the elements are 1-arrays themselves, or a 1-array where the elements are 2-arrays. This important property is directly related to the mechanism of rank extension (see <a href="#Rank-extension">Rank extension</a>).
</p>
<hr>
<span id="Special-objects"></span><div class="header">
<p>
Next: <a href="#The-rank-conjunction" accesskey="n" rel="next">The rank conjunction</a>, Previous: <a href="#Slicing" accesskey="p" rel="prev">Slicing</a>, Up: <a href="#Usage" accesskey="u" rel="up">Usage</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Special-objects-1"></span><h3 class="section">2.7 Special objects</h3>

<dl>
<dt id="index-TensorIndex_003cn_002c">Special&nbsp;object<!-- /@w -->: <strong>TensorIndex&lt;n,</strong> <em>integer_type=ra::dim_t&gt;</em></dt>
<dd><p><code>TensorIndex&lt;n&gt;</code> represents the <code>n</code>-th index of an array expression. <code>TensorIndex&lt;n&gt;</code> is itself an array expression of rank <code>n</code>-1 and size undefined. It must be used with other terms whose dimensions are defined, so that the overall shape of the array expression can be determined.
</p>
<p><code>ra::</code> offers the shortcut <code>ra::_0</code> for <code>ra::TensorIndex&lt;0&gt;{}</code>, etc.
</p></dd></dl>

<div class="example">
<pre class="verbatim">ra::Big&lt;int, 1&gt; v = {1, 2, 3};
cout &lt;&lt; (v - ra::_0) &lt;&lt; endl; // { 1-0, 2-1, 3-2 }
// cout &lt;&lt; (ra::_0) &lt;&lt; endl; // error: TensorIndex cannot drive array expression
// cout &lt;&lt; (v - ra::_1) &lt;&lt; endl; // error: TensorIndex cannot drive array expression
ra::Big&lt;int, 2&gt; a({3, 2}, 0);
cout &lt;&lt; (a + ra::_0 - ra::_1) &lt;&lt; endl; // {{0, -1, -2}, {1, 0, -1}, {2, 1, 0}}
</pre></div>


<hr>
<span id="The-rank-conjunction"></span><div class="header">
<p>
Next: <a href="#Compatibility" accesskey="n" rel="next">Compatibility</a>, Previous: <a href="#Special-objects" accesskey="p" rel="prev">Special objects</a>, Up: <a href="#Usage" accesskey="u" rel="up">Usage</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="The-rank-conjunction-1"></span><h3 class="section">2.8 The rank conjunction</h3>

<p>We have seen in <a href="#Cell-iteration">Cell iteration</a> that it is possible to treat an r-array as an array of lower rank with subarrays as its elements. With the <a href="#x_002diter"><code>iter&lt;cell rank&gt;</code></a> construction, this ‘exploding’ is performed (notionally) on the argument; the operation of the array expression is applied blindly to these cells, whatever they turn out to be.
</p>
<div class="example">
<pre class="verbatim">for_each(my_sort, iter&lt;1&gt;(A)); // (in ra::) my_sort is a regular function, cell rank must be given
for_each(my_sort, iter&lt;0&gt;(A)); // (in ra::) error, bad cell rank
</pre></div>

<p>The array language J has instead the concept of <em>verb rank</em>. Every function (or <em>verb</em>) has an associated cell rank for each of its arguments. Therefore <code>iter&lt;cell rank&gt;</code> is not needed.
</p>
<div class="example">
<pre class="verbatim">for_each(sort_rows, A); // (not in ra::) will iterate over 1-cells of A, sort_rows knows
</pre></div>

<p><code>ra::</code> doesn&rsquo;t have ‘verb ranks’ yet. In practice one can think of <code>ra::</code>&rsquo;s operations as having a verb rank of 0. However, <code>ra::</code> supports a limited form of J&rsquo;s <em>rank conjunction</em> with the function <a href="#x_002dwrank"><code>wrank</code></a>.
</p>
<p>This is an operator that takes one verb (such operators are known as <em>adverbs</em> in J) and produces another verb with different ranks. These ranks are used for rank extension through prefix agreement, but then the original verb is used on the cells that result. The rank conjunction can be nested, and this allows repeated rank extension before the innermost operation is applied.
</p>
<p>A standard example is ‘outer product’.
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;int, 1&gt; a = {1, 2, 3};
ra::Big&lt;int, 1&gt; b = {40, 50};
ra::Big&lt;int, 2&gt; axb = map(ra::wrank&lt;0, 1&gt;([](auto &amp;&amp; a, auto &amp;&amp; b) { return a*b; }),
                            a, b)
</pre><pre class="example">&rArr; axb = {{40, 80, 120}, {50, 100, 150}}
</pre></div>

<p>It works like this. The verb <code>ra::wrank&lt;0, 1&gt;([](auto &amp;&amp; a, auto &amp;&amp; b) { return a*b; })</code> has verb ranks (0, 1), so the 0-cells of <code>a</code> are paired with the 1-cells of <code>b</code>. In this case <code>b</code> has a single 1-cell. The frames and the cell shapes of each operand are:
</p>
<div class="example">
<pre class="verbatim">a: 3 |
b:   | 2
</pre></div>

<p>Now the frames are rank-extended through prefix agreement.
</p>
<div class="example">
<pre class="verbatim">a: 3 |
b: 3 | 2
</pre></div>

<p>Now we need to perform the operation on each cell. The verb <code>[](auto &amp;&amp; a, auto &amp;&amp; b) { return a*b; }</code> has verb ranks (0, 0). This results in the 0-cells of <code>a</code> (which have shape ()) being rank-extended to the shape of the 1-cells of <code>b</code> (which is (2)).
</p>
<div class="example">
<pre class="verbatim">a: 3 | 2
b: 3 | 2
</pre></div>

<p>This use of the rank conjunction is packaged in <code>ra::</code> as the <a href="#x_002dfrom"><code>from</code></a> operator. It supports any number of arguments, not only two.
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;int, 1&gt; a = {1, 2, 3};
ra::Big&lt;int, 1&gt; b = {40, 50};
ra::Big&lt;int, 2&gt; axb = from([](auto &amp;&amp; a, auto &amp;&amp; b) { return a*b; }), a, b)
</pre><pre class="example">&rArr; axb = {{40, 80, 120}, {50, 100, 150}}
</pre></div>

<p>Another example is matrix multiplication. For 2-array arguments C, A and B with shapes C: (m, n) A: (m, p) and B: (p, n), we want to perform the operation C(i, j) += A(i, k)*B(k, j). The axis alignment gives us the ranks we need to use.
</p>
<div class="example">
<pre class="verbatim">C: m |   | n
A: m | p |
B:   | p | n
</pre></div>

<p>First we&rsquo;ll align the first axes of C and A using the cell ranks (1, 1, 2). The cell shapes are:
</p>
<div class="example">
<pre class="verbatim">C: m | n
A: m | p
B:   | p n
</pre></div>

<p>Then we&rsquo;ll use the ranks (1, 0, 1) on the cells:
</p>
<div class="example">
<pre class="verbatim">C: m |   | n
A: m | p |
B:   | p | n
</pre></div>

<p>The final operation is a standard operation on arrays of scalars. In actual <code>ra::</code> syntax:
</p>
<div class="example">
<pre class="verbatim">ra::Big A({3, 2}, {1, 2, 3, 4, 5, 6});
ra::Big B({2, 3}, {7, 8, 9, 10, 11, 12});
ra::Big C({3, 3}, 0.);
for_each(ra::wrank&lt;1, 1, 2&gt;(ra::wrank&lt;1, 0, 1&gt;([](auto &amp;&amp; c, auto &amp;&amp; a, auto &amp;&amp; b) { c += a*b; })), C, A, B);
</pre><pre class="example">&rArr; C = {{27, 30, 33}, {61, 68, 75}, {95, 106, 117}}
</pre></div>

<p>Note that <code>wrank</code> cannot be used to transpose axes in general.
</p>
<p>I hope that in the future something like <code>C(i, j) += A(i, k)*B(k, j)</code>, where <code>i, j, k</code> are special objects, can be automatically translated to the requisite combination of <code>wrank</code> and perhaps also <a href="#x_002dtranspose"><code>transpose</code></a>. For the time being, you have to align or transpose the axes yourself.
</p>
<hr>
<span id="Compatibility"></span><div class="header">
<p>
Next: <a href="#Extension" accesskey="n" rel="next">Extension</a>, Previous: <a href="#The-rank-conjunction" accesskey="p" rel="prev">The rank conjunction</a>, Up: <a href="#Usage" accesskey="u" rel="up">Usage</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Compatibility-1"></span><h3 class="section">2.9 Compatibility</h3>

<span id="Using-other-C-and-C_002b_002b-types-with-ra_003a_003a"></span><h4 class="subsection">2.9.1 Using other C and C++ types with <code>ra::</code></h4>

<span id="index-foreign-type"></span>
<p><code>ra::</code> accepts certain types from outside <code>ra::</code> (<em>foreign types</em>) as array expressions. Generally it is enough to mix the foreign type with a type from <code>ra::</code> and let deduction work.
</p>
<div class="example">
<pre class="verbatim">std::vector&lt;int&gt; x = {1, 2, 3};
ra::Small&lt;int, 3&gt; y = {6, 5, 4};
cout &lt;&lt; (x-y) &lt;&lt; endl;
</pre><pre class="example">-| -5 -3 -1
</pre></div>

<span id="index-start"></span>
<p>Foreign types can be brought into <code>ra::</code> explicitly with the function <a href="#x_002dstart"><code>start</code></a>.
</p>
<div class="example">
<pre class="verbatim">std::vector&lt;int&gt; x = {1, 2, 3};
// cout &lt;&lt; sum(x) &lt;&lt; endl; // error, sum not found
cout &lt;&lt; sum(ra::start(x)) &lt;&lt; endl;
cout &lt;&lt; ra::sum(x) &lt;&lt; endl;
</pre><pre class="example">-| 6
   6
</pre></div>

<p>The following types are accepted as foreign types:
</p>
<ul>
<li> <code>std::vector</code>
produces an expression of rank 1 and dynamic size.
</li><li> <code>std::array</code>
produces an expression of rank 1 and static size.
</li><li> Built-in arrays <span id="index-built_002din-array"></span>
produce an expression of positive rank and static size.
</li><li> Raw pointers
produce an expression of rank 1 and <em>undefined</em> size. Raw pointers must be brought into <code>ra::</code> explicitly with the function <a href="#x_002dptr"><code>ptr</code></a>.
</li></ul>

<p>Compare:
</p>
<div class="example">
<pre class="verbatim">int p[] = {1, 2, 3};
int * z = p;
ra::Big&lt;int, 1&gt; q {1, 2, 3};
q += p; // ok, q is ra::, p is foreign object with size info
ra::start(p) += q; // can't redefine operator+=(int[]), foreign needs ra::start()
// z += q; // error: raw pointer needs ra::ptr()
ra::ptr(z) += p; // ok, size is determined by foreign object p
</pre></div>

<span id="x_002dis_002dscalar"></span><p>Some types are accepted automatically as scalars. These include:
</p><ul>
<li> Any type <code>T</code> for which <code>std::is_scalar_v&lt;T&gt;</code> is true, <em>except</em> pointers. These include <code>char</code>, <code>int</code>, <code>double</code>, etc.
</li><li> <code>std::complex&lt;T&gt;</code>, if you import <code>ra/complex.H</code>.
</li></ul>

<p>You can add your own types as scalar types with the following declaration (see <code>ra/complex.H</code>):
</p>
<pre class="verbatim">    namespace ra { template &lt;&gt; constexpr bool is_scalar_def&lt;MYTYPE&gt; = true; }
</pre>
<p>Otherwise, you can bring a scalar object into <code>ra::</code> on the spot, with the function <a href="#x_002dscalar"><code>scalar</code></a>.
</p>
<span id="Using-ra_003a_003a-types-with-the-STL"></span><h4 class="subsection">2.9.2 Using <code>ra::</code> types with the STL</h4>

<p>General <code>ra::</code> <a href="#Containers-and-views">views</a> provide STL compatible <code>ForwardIterator</code>s through the members <code>begin()</code> and <code>end()</code>. These iterators traverse the elements of the array (0-cells) in row major order, regardless of the internal order of the view.
</p>
<p>For <a href="#Containers-and-views">containers</a> <code>begin()</code> provides <code>RandomAccessIterator</code>s, which is handy for certain functions such as <code>sort</code>. There&rsquo;s no reason why all views couldn&rsquo;t provide <code>RandomAccessIterator</code>, but these wouldn&rsquo;t be efficient in general for ranks above 1, and I haven&rsquo;t implemented them. The container <code>RandomAccessIterator</code>s that are provided are in fact raw pointers.
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;int&gt; x {3, 2, 1}; // x is a Container
auto y = x(); // y is a View on x
// std::sort(y.begin(), y.end()); // error: y.begin() is not RandomAccessIterator
std::sort(x.begin(), x.end()); // ok, we know x is stored in row-major order
</pre><pre class="example">&rArr; x = {1, 2, 3}
</pre></div>

<span id="index-other-libraries_002c-interfacing-with"></span>
<span id="Using-ra_003a_003a-types-with-other-libraries"></span><h4 class="subsection">2.9.3 Using <code>ra::</code> types with other libraries</h4>

<p>When you have to pass arrays back and forth between your program and an external library, perhaps even another language, it is necessary for both sides to agree on a memory layout. <code>ra::</code> gives you access to its own memory layout and allows you to obtain an <code>ra::</code> view on any type of memory.
</p>
<span id="The-good-array-citizen"></span><h4 class="subsubsection">2.9.3.1 The good array citizen</h4>

<p>FIXME Put these in examples/ and reference them here.
</p>
<span id="index-BLIS"></span>
<p>The good array citizen describes its arrays with the same parameters as <code>ra::</code>, that is: a pointer, plus a size and a stride per dimension. You pass those and you&rsquo;re done; you don&rsquo;t have to worry about special cases. Say <a href="https://github.com/flame/blis">BLIS</a>:
</p>
<blockquote>
<pre class="verbatim">#include &lt;blis.h&gt;

ra::Big&lt;double, 2&gt; A({M, K}, ...);
ra::Big&lt;double, 2&gt; B({K, N}, ...);
ra::Big&lt;double, 2&gt; C({M, N}, ...);
double alpha = ...;
double beta = ...;

// C := βC + αAB
bli_dgemm(BLIS_NO_TRANSPOSE, BLIS_NO_TRANSPOSE, M, N, K, &amp;alpha,
          A.data(), A.stride(0), A.stride(1),
          B.data(), B.stride(0), B.stride(1),
          &amp;beta, C.data(), C.stride(0), C.stride(1));
</pre></blockquote>

<span id="index-FFTW"></span>
<p>Another good array citizen, <a href="http://fftw.org">FFTW</a> handles arbitrary rank:
</p>
<blockquote>
<pre class="verbatim">#include &lt;fftw3.h&gt;

...

using complex = std::complex&lt;double&gt;;
static_assert(sizeof(complex)==sizeof(fftw_complex));

// forward DFT over the last r axes of a -&gt; b
void fftw(int r, ra::View&lt;complex&gt; const a, ra::View&lt;complex&gt; b)
{
    int const rank = a.rank();
    assert(r&gt;0 &amp;&amp; r&lt;=rank);
    assert(every(shape(a)==shape(b)));
    fftw_iodim dims[r];
    fftw_iodim howmany_dims[rank-r];
    for (int i=0; i!=rank; ++i) {
        if (i&gt;=rank-r) {
            dims[i-rank+r].n = a.size(i);
            dims[i-rank+r].is = a.stride(i);
            dims[i-rank+r].os = b.stride(i);
        } else {
            howmany_dims[i].n = a.size(i);
            howmany_dims[i].is = a.stride(i);
            howmany_dims[i].os = b.stride(i);
        }
    }
    fftw_plan p;
    p = fftw_plan_guru_dft(r, dims, rank-r, howmany_dims,
                           (fftw_complex *)(a.data()), (fftw_complex *)(b.data()),
                           FFTW_FORWARD, FFTW_ESTIMATE);
    fftw_execute(p);
    fftw_destroy_plan(p);
}
</pre></blockquote>

<span id="index-Guile"></span>
<p>Translating array descriptors from a foreign language should be fairly simple. For example, this is how to convert a <a href="https://www.gnu.org/software/guile/manual/html_node/Accessing-Arrays-from-C.html#Accessing-Arrays-from-C">Guile</a> array view into an <code>ra::</code> view:
</p>
<blockquote>
<pre class="verbatim">    SCM a; // say a is #nf64(...)

    ...

    scm_t_array_handle h;
    scm_array_get_handle(a, &amp;h);
    scm_t_array_dim const * dims = scm_array_handle_dims(&amp;h);
    View&lt;double&gt; v(map([](int i) { return ra::Dimv {dim[i].ubnd-dim[i].lbnd+1, dim[i].inc}; },
                       ra::iota(scm_array_handle_rank(&amp;h))),
                   scm_array_handle_f64_writable_elements(&amp;h));

    ...

    scm_array_handle_release(&amp;h);
</pre></blockquote>

<span id="index-Numpy-2"></span>
<span id="index-Python"></span>
<p>Numpy&rsquo;s C API has the type <a href="https://docs.scipy.org/doc/numpy/reference/c-api.array.html"><code>PyArrayObject</code></a> which can be used in the same way as Guile&rsquo;s <code>scm_t_array_handle</code> in the example above.
</p>
<p>Generally it is simpler to let the foreign language handle the memory, even though there should be ways to transfer ownership (e.g. Guile has <a href="https://www.gnu.org/software/guile/manual/html_node/SRFI_002d4-API.html#index-scm_005ftake_005ff64vector"><code>scm_take_xxx</code></a>).
</p>
<span id="The-bad-array-citizen"></span><h4 class="subsubsection">2.9.3.2 The bad array citizen</h4>

<p>Unfortunately there are many libraries that don&rsquo;t accept general array parameters, or that do strange things with particular values of sizes and/or strides.
</p>
<p>The most common case is that a library doesn&rsquo;t handle strides at all, and it only accepts unit stride for rank 1 arrays, or packed row-major or column-major storage for higher rank arrays. In that case, you might be forced to copy your array before passing it along.
</p>
<p>FIXME using is_c_order, etc.
</p>
<p>Other libraries do accept strides, but not general ones. For example <a href="https://www.netlib.org/blas">https://www.netlib.org/blas</a>&rsquo; <code>cblas_dgemm</code> has this prototype:
</p>
<blockquote>
<pre class="verbatim">cblas_dgemm(order, transA, transB, m, n, k, alpha, A, lda, B, ldb, beta, C, ldc);
</pre></blockquote>

<p><code>A</code>, <code>B</code>, <code>C</code> are (pointers to) 2-arrays, but the routine accepts only one stride argument for each (<code>lda</code>, etc.). CBLAS also doesn&rsquo;t understand <code>lda</code> as a general stride, but rather as the dimension of a larger array that you&rsquo;re slicing <code>A</code> from, and some implementations will handle negative or zero <code>lda</code> in bizarre ways.
</p>
<p>Sometimes you can work around this by fiddling with <code>transA</code> and <code>transB</code>, but in general you need to check your array parameters and you may need to make copies.
</p>
<span id="index-OpenGL"></span>
<p>OpenGL is another library that requires <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml">contortions:</a>
</p>
<blockquote>
<pre class="verbatim">void glVertexAttribPointer(GLuint index,
                           GLint size,
                           GLenum type,
                           GLboolean normalized,
                           GLsizei stride,
                           const GLvoid * pointer);
</pre>
<p>[...]
</p>
<p><em>stride</em>
</p>
<blockquote>
<p>Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
    </p></blockquote>
</blockquote>

<p>It isn&rsquo;t clear whether negative strides are legal, either. So just as with CBLAS, passing general array views will require copies.
</p>
<hr>
<span id="Extension"></span><div class="header">
<p>
Next: <a href="#Functions" accesskey="n" rel="next">Functions</a>, Previous: <a href="#Compatibility" accesskey="p" rel="prev">Compatibility</a>, Up: <a href="#Usage" accesskey="u" rel="up">Usage</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Extension-1"></span><h3 class="section">2.10 Extension</h3>

<span id="New-scalar-types"></span><h4 class="subsection">2.10.1 New scalar types</h4>

<p><code>ra::</code> will let you construct arrays of arbitrary types out of the box. This is the same functionality you get with e.g. <code>std::vector</code>.
</p>
<div class="example">
<pre class="verbatim">struct W { int x; }
ra::Big&lt;W, 2&gt; w = {{ {4}, {2} }, { {1}, {3} }};
cout &lt;&lt; W(1, 1).x &lt;&lt; endl;
cout &lt;&lt; amin(map([](auto &amp;&amp; x) { return w.x; }, w)) &lt;&lt; endl;
</pre><pre class="example">-| 3
   1
</pre></div>

<p>However, if you want to mix arbitrary types in array operations, you&rsquo;ll need to tell <code>ra::</code> that that is actually what you want. This is to avoid conflicts with other libraries.
</p>
<div class="example">
<pre class="verbatim">namespace ra { template &lt;&gt; constexpr bool is_scalar_def&lt;W&gt; = true; }
...
W ww {11};
for_each([](auto &amp;&amp; x, auto &amp;&amp; y) { cout &lt;&lt; (x.x + y.y) &lt;&lt; &quot; &quot;; }, w, ww); // ok
</pre><pre class="example">-| 15 13 12 14
</pre></div>

<p>but
</p>
<div class="example">
<pre class="verbatim">struct U { int x; }
U uu {11};
for_each([](auto &amp;&amp; x, auto &amp;&amp; y) { cout &lt;&lt; (x.x + y.y) &lt;&lt; &quot; &quot;; }, w, uu); // error: can't find ra::start(U)
</pre></div>

<span id="x_002dnew_002darray_002doperations"></span><span id="New-array-operations"></span><h4 class="subsection">2.10.2 New array operations</h4>

<p><code>ra::</code> provides array extensions for standard operations such as <code>+</code>, <code>*</code>, <code>cos</code> <a href="#x_002dscalar_002dops">and so on</a>. You can add array extensions for your own operations in the obvious way, with <a href="#x_002dmap"><code>map</code></a> (but note the namespace qualifiers):
</p>
<div class="example">
<pre class="verbatim">return_type my_fun(...) { };
...
namespace ra {
template &lt;class ... A&gt; inline auto
my_fun(A &amp;&amp; ... a)
{
    return map(::my_fun, std::forward&lt;A&gt;(a) ...);
}
} // namespace ra
</pre></div>

<span id="index-Blitz_002b_002b-2"></span>
<p>If you compare this with what Blitz++ had to do, modern C++ sure has made our lives easier.
</p>
<p>If <code>my_fun</code> is an overload set, you can use
</p>
<div class="example">
<pre class="verbatim">namespace ra {
template &lt;class ... A&gt; inline auto
my_fun(A &amp;&amp; ... a)
{
    return map([](auto &amp;&amp; ... a) { return ::my_fun(a ...); }, std::forward&lt;A&gt;(a) ...);
}
} // namespace ra
</pre></div>

<hr>
<span id="Functions"></span><div class="header">
<p>
Next: <a href="#Error-handling" accesskey="n" rel="next">Error handling</a>, Previous: <a href="#Extension" accesskey="p" rel="prev">Extension</a>, Up: <a href="#Usage" accesskey="u" rel="up">Usage</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Functions-1"></span><h3 class="section">2.11 Functions</h3>

<p>You don&rsquo;t need to use <a href="#Array-operations"><code>map</code></a> every time you want to do something with arrays in <code>ra::</code>. A number of array functions are already defined.
</p>
<span id="x_002dscalar_002dops"></span><span id="Standard-scalar-operations"></span><h4 class="subsection">2.11.1 Standard scalar operations</h4>

<p><code>ra::</code> defines array extensions for <code>+</code>, <code>-</code> (both unary and binary), <code>*</code>, <code>/</code>, <code>!</code>, <code>&amp;&amp;</code>, <code>||</code><a id="DOCF8" href="#FOOT8"><sup>8</sup></a>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>pow</code>, <code>sqr</code>, <code>abs</code>, <code>cos</code>, <code>sin</code>, <code>exp</code>, <code>expm1</code>, <code>sqrt</code>, <code>log</code>, <code>log1p</code>, <code>log10</code>, <code>isfinite</code>, <code>isnan</code>, <code>isinf</code>, <code>max</code>, <code>min</code>, <code>odd</code>, <code>asin</code>, <code>acos</code>, <code>atan</code>, <code>atan2</code>, <code>cosh</code>, <code>sinh</code>, and <code>tanh</code>. Extending other scalar operations is straightforward; see <a href="#x_002dnew_002darray_002doperations">New array operations</a>. <code>ra::</code> also defines (and extends) the non-standard functions <a href="#x_002dsqr"><code>sqr</code></a>, <a href="#x_002dsqrm"><code>sqrm</code></a>, <a href="#x_002dconj"><code>conj</code></a>, <a href="#x_002drel_002derror"><code>rel_error</code></a>, and <a href="#x_002dxI"><code>xI</code></a>.
</p>
<p>For example:
</p><div class="example">
<pre class="verbatim">cout &lt;&lt; exp(ra::Small&lt;double, 3&gt; {4, 5, 6}) &lt;&lt; endl;
</pre><pre class="example">  -| 54.5982 148.413 403.429
</pre></div>

<span id="Conditional-operations"></span><h4 class="subsection">2.11.2 Conditional operations</h4>

<p><a href="#x_002dmap"><code>map</code></a> evaluates all of its arguments before passing them along to its operator. This isn&rsquo;t always what you want. The simplest example is <code>where(condition, iftrue, iffalse)</code>, which returns an expression that will evaluate <code>iftrue</code> when <code>condition</code> is true and <code>iffalse</code> otherwise.
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;double&gt; x ...
ra::Big&lt;double&gt; y = where(x&gt;0, expensive_expr_1(x), expensive_expr_2(x));
</pre></div>

<p>Here <code>expensive_expr_1</code> and <code>expensive_expr_2</code> are array expressions. So the computation of the other arm would be wasted if one were to do instead
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;double&gt; y = map([](auto &amp;&amp; w, auto &amp;&amp; t, auto &amp;&amp; f) -&gt; decltype(auto) { return w ? t : f; }
                        x&gt;0, expensive_expr_1(x), expensive_function_2(x));
</pre></div>

<p>If the expressions have side effects, then <code>map</code> won&rsquo;t even give the right result.
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;int, 1&gt; o = {};
ra::Big&lt;int, 1&gt; e = {};
ra::Big&lt;int, 1&gt; n = {1, 2, 7, 9, 12};
ply(where(odd(n), map([&amp;o](auto &amp;&amp; x) { o.push_back(x); }, n), map([&amp;e](auto &amp;&amp; x) { e.push_back(x); }, n)));
cout &lt;&lt; &quot;o: &quot; &lt;&lt; ra::noshape &lt;&lt; o &lt;&lt; &quot;, e: &quot; &lt;&lt; ra::noshape &lt;&lt; e &lt;&lt; endl;
</pre><pre class="example">-| o: 1 7 9, e: 2 12
</pre></div>

<p>FIXME Very artificial example.
FIXME Do we want to expose ply(); this is the only example in the manual that uses it.
</p>
<p>When the choice is between more than two expressions, there&rsquo;s <a href="#x_002dpick"><code>pick</code></a>, which operates similarly.
</p>
<span id="Special-operations"></span><h4 class="subsection">2.11.3 Special operations</h4>

<p>Some operations are essentially scalar operations, but require special syntax and would need a lambda wrapper to be used with <code>map</code>. <code>ra::</code> comes with a few of these already defined.
</p>
<p>FIXME
</p>
<span id="Elementwise-reductions"></span><h4 class="subsection">2.11.4 Elementwise reductions</h4>

<p><code>ra::</code> defines the whole-array one-argument reductions <code>any</code>, <code>every</code>, <code>amax</code>, <code>amin</code>, <code>sum</code>, <code>prod</code> and the two-argument reductions <code>dot</code> and <code>cdot</code>. Note that <code>max</code> and <code>min</code> are two-argument scalar operations with array extensions, while <code>amax</code> and <code>amin</code> are reductions. <code>any</code> and <code>every</code> are short-circuiting.
</p>
<p>You can define similar reductions in the same way that <code>ra::</code> does it:
</p>
<div class="example">
<pre class="verbatim">template &lt;class A&gt;
inline auto op_reduce(A &amp;&amp; a)
{
    T c = op_default;
    for_each([&amp;c](auto &amp;&amp; a) { c = op(c, a); }, a);
    return c;
}
</pre></div>

<p>Often enough you need to reduce over particular axes. This is possible by combining assignment operators with the <a href="#Rank-extension">rank extension</a> mechanism, or using the <a href="#The-rank-conjunction">rank conjunction</a>, or iterating over <a href="#Cell-iteration">cells of higher rank</a>. For example:
</p>
<div class="example">
<pre class="verbatim">    ra::Big&lt;double, 2&gt; a({m, n}, ...);

    ra::Big&lt;double, 1&gt; sum_rows({n}, 0.);
    iter&lt;1&gt;(sum_rows) += iter&lt;1&gt;(a);
    // for_each(ra::wrank&lt;1, 1&gt;([](auto &amp; c, auto &amp;&amp; a) { c += a; }), sum_rows, a) // alternative
    // sum_rows += transpose&lt;1, 0&gt;(a); // another

    ra::Big&lt;double, 1&gt; sum_cols({m}, 0.);
    sum_cols += a;
</pre></div>


<p>FIXME example with assignment op
</p>
<p>A few common operations of this type are already packaged in <code>ra::</code>.
</p>
<span id="Special-reductions"></span><h4 class="subsection">2.11.5 Special reductions</h4>

<p><code>ra::</code> defines the following special reductions.
</p>
<p>FIXME
</p>
<span id="Shortcut-reductions"></span><h4 class="subsection">2.11.6 Shortcut reductions</h4>

<p>Some reductions do not need to traverse the whole array if a certain condition is encountered early. The most obvious ones are the reductions of <code>&amp;&amp;</code> and <code>||</code>, which <code>ra::</code> defines as <code>every</code> and <code>any</code>.
</p>
<p>FIXME
</p>
<p>These operations are defined on top of another function <code>early</code>.
</p>
<p>FIXME early
</p>
<p>The following is often useful.
</p>
<p>FIXME lexicographical compare etc.
</p>
<hr>
<span id="Error-handling"></span><div class="header">
<p>
Previous: <a href="#Functions" accesskey="p" rel="prev">Functions</a>, Up: <a href="#Usage" accesskey="u" rel="up">Usage</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Error-handling-1"></span><h3 class="section">2.12 Error handling</h3>

<p>Error handling in <code>ra::</code> is barebones. It is controlled by two macros:
</p>
<ul>
<li> <code>RA_CHECK_BOUNDS</code>
is a binary flag. If it is 0, runtime checks are disabled. The default is 1. <code>RA_CHECK_BOUND</code> controls all runtime checks on input arguments, not only bounds checks. If the checks are enabled,
</li><li> <code>RA_ASSERT</code>
is called with a single argument, an expression that evaluates to true (in the <code>ra::</code> namespace) if the check passes. The default value of <code>RA_ASSERT</code> is <code>assert</code> (from <code>&lt;cassert&gt;</code>) which will abort the program otherwise.
</li></ul>

<p><code>ra::</code> contains uses of <code>assert</code> for checking invariants or for sanity checks that are separate from uses of <code>RA_ASSERT</code>. Those can be disabled in the usual way with <code>-DNDEBUG</code>. The use of <code>-DNDEBUG</code> is untested.
</p>
<p><code>RA_ASSERT</code> is provided so that you can replace the default <code>assert</code> with something more appropriate for your program. <code>examples/throw.C</code> in the distribution shows how to throw an user-defined exception instead.
</p>
<hr>
<span id="Extras"></span><div class="header">
<p>
Next: <a href="#Hazards" accesskey="n" rel="next">Hazards</a>, Previous: <a href="#Usage" accesskey="p" rel="prev">Usage</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Extras-1"></span><h2 class="chapter">3 Extras</h2>


<hr>
<span id="Hazards"></span><div class="header">
<p>
Next: <a href="#Internals" accesskey="n" rel="next">Internals</a>, Previous: <a href="#Extras" accesskey="p" rel="prev">Extras</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Hazards-1"></span><h2 class="chapter">4 Hazards</h2>

<p>Some of these issues arise because <code>ra::</code> applies its principles systematically, which can have surprising results. Still others are the result of unfortunate compromises. And a few are just bugs.
</p>
<span id="Assignment-to-views"></span><h3 class="section">4.1 Assignment to views</h3>

<p>FIXME
With dynamic-shape containers (e.g. <code>Big</code>), <code>operator=</code> replaces the left hand side instead of writing over its contents. This behavior is inconsistent with <code>View::operator=</code> and is there only so that istream &gt;&gt; container may work; do not rely on it.
</p>
<span id="View-of-const-vs-const-view"></span><h3 class="section">4.2 View of const vs const view</h3>


<p>FIXME
Passing view arguments by reference
</p>
<span id="Array-iterators-and-temporaries"></span><h3 class="section">4.3 Array iterators and temporaries</h3>

<p>FIXME
</p>
<span id="Rank-extension-in-assignments"></span><h3 class="section">4.4 Rank extension in assignments</h3>

<p>Assignment of an expression onto another expression of lower rank may not do what you expect. This example matches <code>a</code> and 3 [both of shape ()] with a vector of shape (3). This is equivalent to <code>{a=3+4; a=3+5; a=3+6;}</code>. You may get a different result depending on the order of traversal.
</p>
<div class="example">
<pre class="verbatim">int a = 0;
ra::scalar(a) = 3 + ra::Small&lt;int, 3&gt; {4, 5, 6};
</pre><pre class="example">  &rArr; a = 9
</pre></div>

<span id="Performance-pitfalls-of-rank-extension"></span><h3 class="section">4.5 Performance pitfalls of rank extension</h3>

<p>In the following example where <code>b</code> has its shape extended from (3) to (3, 4), <code>f</code> is called 12 times, even though only 3 calls are needed if <code>f</code> doesn&rsquo;t have side effects. In such cases it might be preferrable to write the outer loop explicitly, or to do some precomputation.
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;int, 2&gt; a = {{1, 2, 3, 4}, {5, 6, 7, 8} {9, 10, 11, 12}};
ra::Big&lt;int, 1&gt; b = {1, 2, 3};
ra::Big&lt;int, 2&gt; c = map(f, b) + a;
</pre></div>

<span id="Chained-assignment"></span><h3 class="section">4.6 Chained assignment</h3>

<p>FIXME
When <code>a=b=c</code> works, it operates as <code>b=c; a=b;</code> and not as an array expression.
</p>
<span id="Unregistered-scalar-types"></span><h3 class="section">4.7 Unregistered scalar types</h3>

<p>FIXME
<code>View&lt;T, N&gt; x; x = T()</code> fails if <code>T</code> isn&rsquo;t registered as <code>is_scalar</code>.
</p>
<ol>
<li> Item 0
</li><li> Item 1
</li><li> Item 2
</li></ol>

<hr>
<span id="Internals"></span><div class="header">
<p>
Next: <a href="#The-future" accesskey="n" rel="next">The future</a>, Previous: <a href="#Hazards" accesskey="p" rel="prev">Hazards</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Internals-1"></span><h2 class="chapter">5 Internals</h2>

<p><code>ra::</code> has two main components: a set of container classes, and the expression template mechanism. The container classes provide leaves for the expression template trees, and the container classes also make some use of the expression template mechanism internally (e.g. in the selection operator, or for initialization).
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Type-hierarchy" accesskey="1">Type hierarchy</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">From <code>Containers</code> to <code>Flat</code>.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Driving-expressions" accesskey="2">Driving expressions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">The term in charge.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Loop-types" accesskey="3">Loop types</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Chosen for performance.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Introspection" accesskey="4">Introspection</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Speaking to myself.
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Compiling-and-running" accesskey="5">Compiling and running</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Practical matters.
</td></tr>
</table>

<hr>
<span id="Type-hierarchy"></span><div class="header">
<p>
Next: <a href="#Driving-expressions" accesskey="n" rel="next">Driving expressions</a>, Up: <a href="#Internals" accesskey="u" rel="up">Internals</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Type-hierarchy-1"></span><h3 class="section">5.1 Type hierarchy</h3>

<p>This is a rough and possibly not very accurate summary. I&rsquo;m hoping the planned feature of ‘C++ concepts’ will force me to be more systematic about it all.
</p>
<ul>
<li> <b>Container</b> &mdash; <code>Big</code> <code>Shared</code> <code>Unique</code> <code>Small</code>

<p>These are array types that own their data in one way or another. Creating or destroying these objects may allocate or deallocate memory, respectively.
</p>
</li><li> <b>View</b> &mdash; <code>View</code> <code>SmallView</code>

<p>These are array views into data in memory. Access to their contents doesn&rsquo;t involve computation and they may be writable. Any of the <b>Container</b> types can be treated as a <b>View</b>, but one may also create <b>View</b>s that aren&rsquo;t associated with any <b>Container</b>, for example into memory allocated with a different library. Creating and destroying <b>View</b>s doesn&rsquo;t allocate or deallocate memory for array elements.
</p>
</li><li> <b>ArrayIterator</b> &mdash; <code>Expr</code> <code>Ryn</code> <code>Pick</code> <code>cell_iterator</code> <code>cell_iterator_small</code> <code>Iota</code> <code>Vector</code> <code>Scalar</code>

<p>This is a traversable object. <b>ArrayIterator</b>s are accepted by all the array functions such as <code>map</code>, <code>for_each</code>, etc. <b>ArrayIterator</b>s can be created from <b>View</b>s and from certain foreign array-like types primarily through the function <code>start</code>. In most cases this is done automatically when those types are used in array expressions.
</p>
</li><li> <b>Ravelable</b> &mdash; <code>cell_iterator</code> <code>cell_iterator_small</code> <code>Iota</code> <code>Vector</code> <code>Scalar</code>

<p>This is a kind of <b>ArrayIterator</b> that provides a <code>flat()</code> method to obtain a linearized view of a section of the array. Together with the methods <code>size()</code>, <code>stride()</code>, <code>keep_stride()</code> and <code>adv()</code>, a loop involving only <b>Ravelable</b>s can have its inner loop unfolded and traversed using <b>Flat</b> objects. This is faster than a multidimensional loop, especially if the inner dimensions of the loop are small.
</p>
</li><li> <b>Indexable</b> <code>cell_iterator</code> <code>cell_iterator_small</code> <code>Iota</code> <code>Vector</code> <code>Scalar</code> <code>TensorIndex</code>

<p>This is a kind of <b>ArrayIterator</b> that provides an <code>at(i ...)</code> method for random access to any element of the array.<a id="DOCF9" href="#FOOT9"><sup>9</sup></a>
</p>
</li><li> <b>Flat</b> <code>Flat</code> <code>PickFlat</code> <code>CellFlat</code> <code>IotaFlat</code> <code>ScalarFlat</code>

<p>These are pointerlike types that are meant to be traversed linearly. They have methods <code>operator+=</code> (to advance) and <code>operator*</code> (to derreference). <b>Flat</b> objects are obtained from <b>Ravelable</b> objects through a method <code>flat</code>.
</p>
</li></ul>


<hr>
<span id="Driving-expressions"></span><div class="header">
<p>
Next: <a href="#Loop-types" accesskey="n" rel="next">Loop types</a>, Previous: <a href="#Type-hierarchy" accesskey="p" rel="prev">Type hierarchy</a>, Up: <a href="#Internals" accesskey="u" rel="up">Internals</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Driving-expressions-1"></span><h3 class="section">5.2 Driving expressions</h3>

<p>The execution of an expression template begins with the selection of a term of the expression as its &lsquo;driver&rsquo;. This is simply the term of highest rank. If two or more terms share the same highest rank at the top level of the expression tree, then if one of the terms has static size and the others have dynamic size, then the term with static size is selected as driver<a id="DOCF10" href="#FOOT10"><sup>10</sup></a>. Otherwise the first of all the terms is selected as driver. The driver defines the bounds of the traversal and the dimensions that the other terms must agree with.
</p>
<p>In the current version of <code>ra::</code>, the driver is always selected at compile time<a id="DOCF11" href="#FOOT11"><sup>11</sup></a>. This means that it&rsquo;s possible for an expression to fail at run time if that&rsquo;s when <code>ra::</code> finds out that the term it has selected as driver isn&rsquo;t, in fact, that of the highest rank. This bug can happen anytime variable rank expressions are involved.
</p>
<p>Once we have a driver, we select a traversal method depending on the types of the arguments. <code>ra::</code> has two traversal methods, both based on pointer-like iterators. <code>ply_ravel</code> is used for dynamic-size expressions and <code>plyf</code> for static-size expressions.
</p>
<p>Then we select an order of traversal. <code>ra::</code> supports ‘array’ orders, meaning that the dimensions are sorted in a certain way from outermost to innermost and a full axis is traversed before one advances on the dimension outside. However, currently (v6) there is no heuristic to choose a dimension order, so traversal always happens in row-major order (which shouldn&rsquo;t be relied upon). <code>ply_ravel</code> will unroll as many innermost dimensions as it can, and in some cases traversal will be executed in a single 1D loop.
</p>
<hr>
<span id="Loop-types"></span><div class="header">
<p>
Next: <a href="#Introspection" accesskey="n" rel="next">Introspection</a>, Previous: <a href="#Driving-expressions" accesskey="p" rel="prev">Driving expressions</a>, Up: <a href="#Internals" accesskey="u" rel="up">Internals</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Loop-types-1"></span><h3 class="section">5.3 Loop types</h3>

<p>TODO
</p>
<hr>
<span id="Introspection"></span><div class="header">
<p>
Next: <a href="#Compiling-and-running" accesskey="n" rel="next">Compiling and running</a>, Previous: <a href="#Loop-types" accesskey="p" rel="prev">Loop types</a>, Up: <a href="#Internals" accesskey="u" rel="up">Internals</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Introspection-1"></span><h3 class="section">5.4 Introspection</h3>

<p><code>ra::ra-traits</code> is a template defined for Containers and Views, incuding foreign ones. It&rsquo;s not defined for expression types
</p>
<hr>
<span id="Compiling-and-running"></span><div class="header">
<p>
Previous: <a href="#Introspection" accesskey="p" rel="prev">Introspection</a>, Up: <a href="#Internals" accesskey="u" rel="up">Internals</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Compiling-and-running-1"></span><h3 class="section">5.5 Compiling and running</h3>

<p>The following boolean <code>#define</code>s affect the behavior of <code>ra::</code>.
</p>
<ul>
<li> <code>RA_CHECK_BOUNDS</code> (default 1):  Check bounds on dimension agreement (e.g. <code>Big&lt;int, 1&gt; {2, 3} + Big&lt;int, 1&gt; {1, 2, 3}</code>) and random array accesses (e.g. <code>Small&lt;int, 2&gt; a = 0; int i = 10; a[i] = 0;</code>).
</li><li> <code>RA_USE_BLAS</code> (default 0): Try to use BLAS for certain rank 1 and rank 2 operations. Currently this is only used by some of the benchmarks and not by the library itself.
</li><li> <code>RA_OPTIMIZE</code> (default 1): Replace certain expressions by others that are expected to perform better. This acts as a global mask on other <code>RA_OPTIMIZE_xxx</code> flags.
</li><li> <code>RA_OPTIMIZE_IOTA</code> (default 1): Perform immediately (beat) certain operations on <code>ra::Iota</code> objects. For example, <code>ra::Iota(3, 0) + 1</code> becomes <code>ra::Iota(3, 1)</code> instead of a two-operand expression template.
</li><li> <code>RA_OPTIMIZE_SMALLVECTOR</code> (default 0): Perform immediately certain operations on <code>ra::Small</code> objects, using small vector intrinsics. Currently this only works on <b>gcc</b> and doesn&rsquo;t necessarily result in improved performance.
</li></ul>


<p><code>ra::</code> comes with three kinds of tests: examples, proper tests, and benchmarks. <code>ra::</code> uses its own crude test and benchmark suites. Run <code>CXXFLAGS=-O3 scons</code> from the top directory of the distribution to build and run them all.  Alternatively, you can use <code>CXXFLAGS=-O3 cmake . &amp;&amp; make &amp;&amp; make test</code>.
</p>
<p>TODO Flags and notes about different compilers
</p>
<hr>
<span id="The-future"></span><div class="header">
<p>
Next: <a href="#Reference" accesskey="n" rel="next">Reference</a>, Previous: <a href="#Internals" accesskey="p" rel="prev">Internals</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="The-future-1"></span><h2 class="chapter">6 The future</h2>

<span id="Error-messages"></span><h3 class="section">6.1 Error messages</h3>

<p>FIXME
</p>
<span id="Reductions"></span><h3 class="section">6.2 Reductions</h3>

<p>FIXME
</p>
<span id="Etc"></span><h3 class="section">6.3 Etc</h3>

<p>FIXME
</p>
<hr>
<span id="Reference"></span><div class="header">
<p>
Next: <a href="#Sources" accesskey="n" rel="next">Sources</a>, Previous: <a href="#The-future" accesskey="p" rel="prev">The future</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Reference-1"></span><h2 class="chapter">7 Reference</h2>

<span id="x_002dmap"></span><dl>
<dt id="index-map">Function: <strong>map</strong> <em>op expr ...</em></dt>
<dd><p>Create an array expression that applies <var>op</var> to <var>expr</var> ...
</p></dd></dl>

<p>For example:
</p><div class="example">
<pre class="verbatim">ra::Big&lt;double, 1&gt; x = map(cos, ra::Small&lt;double, 1&gt; {0.});
</pre><pre class="example">&rArr; x = { 1. }
</pre></div>

<p><var>op</var> can return a reference. A typical use is subscripting. For example (TODO better example, e.g. using STL types):
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;int, 2&gt; x = {{3, 3}, 0.};
map([](auto &amp;&amp; i, auto &amp;&amp; j) -&gt; int &amp; { return x(i, j); },
    ra::Big&lt;int, 1&gt; {0, 1, 1, 2}, ra::Big&lt;int, 1&gt; {1, 0, 2, 1})
  = 1;
</pre><pre class="example">&rArr; x = {{0, 1, 0}, {1, 0, 1}, {0, 1, 0}}
</pre></div>

<p>Here the anonymous function can be replaced by simply <code>x</code>. Remember that unspecified return type defaults to (value) <code>auto</code>, so either a explicit type or <code>decltype(auto)</code> should be used if you want to return a reference.
</p>
<span id="index-for_005feach"></span>
<span id="x_002dfor_005feach"></span><dl>
<dt id="index-for_005feach-1">Function: <strong>for_each</strong> <em>op expr ...</em></dt>
<dd><p>Create an array expression that applies <var>op</var> to <var>expr</var> ..., and traverse it.
</p></dd></dl>

<p><var>op</var> is run for effect; whatever it returns is discarded. For example:
</p><div class="example">
<pre class="verbatim">double s = 0.;
for_each([&amp;s](auto &amp;&amp; a) { s+=a; }, ra::Small&lt;double, 1&gt; {1., 2., 3})
</pre><pre class="example">&rArr; s = 6.
</pre></div>

<span id="index-ply"></span>
<span id="x_002dply"></span><dl>
<dt id="index-ply-1">Function: <strong>ply</strong> <em>expr</em></dt>
<dd><p>Traverse <var>expr</var>. <code>ply</code> returns <code>void</code> so <var>expr</var> should be run for effect.
</p></dd></dl>

<p>It is rarely necessary to use <code>ply</code>. Expressions are traversed automatically when they are assigned to views, for example, or printed out. <a href="#x_002dfor_005feach"><code>for_each</code></a><code>(...)</code> (which is actually <code>ply(map(...))</code> should cover most other uses.
</p>
<div class="example">
<pre class="verbatim">double s = 0.;
ply(map([&amp;s](auto &amp;&amp; a) { s+=a; }, ra::Small&lt;double, 1&gt; {1., 2., 3})) // same as for_each
</pre><pre class="example">&rArr; s = 6.
</pre></div>

<span id="index-pack"></span>
<span id="x_002dpack"></span><dl>
<dt id="index-pack-1">Function: <strong>pack</strong> <em>&lt;type&gt; expr ...</em></dt>
<dd><p>Create an array expression that brace-constructs <var>type</var> from <var>expr</var> ...
</p></dd></dl>

<span id="index-cast"></span>
<span id="x_002dcast"></span><dl>
<dt id="index-cast-1">Function: <strong>cast</strong> <em>&lt;type&gt; expr</em></dt>
<dd><p>Create an array expression that casts <var>expr</var> into <var>type</var>.
</p></dd></dl>

<span id="index-pick"></span>
<span id="x_002dpick"></span><dl>
<dt id="index-pick-1">Function: <strong>pick</strong> <em>select_expr expr ...</em></dt>
<dd><p>Create an array expression that selects the first of <var>expr</var> ... if <var>select_expr</var> is 0, the second if <var>select_expr</var> is 1, and so on. The expressions that are not selected are not looked up.
</p></dd></dl>

<p>This function cannot be defined using <a href="#x_002dmap"><code>map</code></a>, because <code>map</code> looks up each one of its argument expressions before calling <var>op</var>.
</p>
<p>For example:
</p><div class="example">
<pre class="verbatim">    ra::Small&lt;int, 3&gt; s {2, 1, 0};
    ra::Small&lt;double, 3&gt; z = pick(s, s*s, s+s, sqrt(s));
</pre><pre class="example">  &rArr; z = {1.41421, 2, 0}
</pre></div>

<span id="index-where"></span>
<span id="x_002dwhere"></span><dl>
<dt id="index-where-1">Function: <strong>where</strong> <em>pred_expr true_expr false_expr</em></dt>
<dd><p>Create an array expression that selects <var>true_expr</var> if <var>pred_expr</var> is <code>true</code>, and <var>false_expr</var> if <var>pred_expr</var> is <code>false</code>. The expression that is not selected is not looked up.
</p></dd></dl>

<p>For example:
</p><div class="example">
<pre class="verbatim">    ra::Big&lt;double, 1&gt; s {1, -1, 3, 2};
    s = where(s&gt;=2, 2, s); // saturate s
</pre><pre class="example">  &rArr; s = {1, -1, 2, 2}
</pre></div>

<span id="index-from"></span>
<span id="x_002dfrom"></span><dl>
<dt id="index-from-1">Function: <strong>from</strong> <em>op ... expr</em></dt>
<dd><p>Create outer product expression. This is defined as <em>E = from(op, e₀, e₁ ...)</em> ⇒ <em>E(i₀₀, i₀₁ ..., i₁₀, i₁₁, ..., ...) = op[e₀(i₀₀, i₀₁, ...), e₁(i₁₀, i₁₁, ...), ...]</em>.
</p></dd></dl>

<p>For example:
</p><div class="example">
<pre class="verbatim">    ra::Big&lt;double, 1&gt; a {1, 2, 3};
    ra::Big&lt;double, 1&gt; b {10, 20, 30};
    ra::Big&lt;double, 2&gt; axb = from([](auto &amp;&amp; a, auto &amp;&amp; b) { return a*b; }, a, b)
</pre><pre class="example">  &rArr; axb = {{10, 20, 30}, {20, 40, 60}, {30, 60, 90}}
</pre></div>

<div class="example">
<pre class="verbatim">    ra::Big&lt;int, 1&gt; i {2, 1};
    ra::Big&lt;int, 1&gt; j {0, 1};
    ra::Big&lt;double, 2&gt; A = {{1, 2}, {3, 4}, {5, 6}};
    ra::Big&lt;double, 2&gt; Aij = from(A, i, j)
</pre><pre class="example">  &rArr; Aij = {{6, 5}, {4, 3}}
</pre></div>

<p>The last example is more or less how <code>A(i, j)</code> is actually implemented (see <a href="#The-rank-conjunction">The rank conjunction</a>).
</p>
<span id="index-at"></span>
<span id="x_002dat"></span><dl>
<dt id="index-at-1">Function: <strong>at</strong> <em>expr indices</em></dt>
<dd><p>Look up <var>expr</var> at each element of <var>indices</var>, which shall be a multi-index into <var>expr</var>.
</p></dd></dl>

<p>This can be used for sparse subscripting. For example:
</p><div class="example">
<pre class="verbatim">    ra::Big&lt;int, 2&gt; A = {{100, 101}, {110, 111}, {120, 121}};
    ra::Big&lt;ra::Small&lt;int, 2&gt;, 2&gt; i = {{{0, 1}, {2, 0}}, {{1, 0}, {2, 1}}};
    ra::Big&lt;int, 2&gt; B = at(A, i);
</pre><pre class="example">  &rArr; B = {{101, 120}, {110, 121}}
</pre></div>

<span id="index-wrank"></span>
<span id="x_002dwrank"></span><dl>
<dt id="index-wrank-1">Function: <strong>wrank</strong> <em>&lt;input_rank ...&gt; op</em></dt>
<dd><p>Wrap op using a rank conjunction (see <a href="#The-rank-conjunction">The rank conjunction</a>).
</p></dd></dl>

<p>For example: TODO
</p><div class="example">
<pre class="verbatim"></pre><pre class="example">  &rArr; x = 0
</pre></div>

<span id="index-transpose"></span>
<span id="x_002dtranspose"></span><dl>
<dt id="index-transpose-1">Function: <strong>transpose</strong> <em>&lt;axes ...&gt; view</em></dt>
<dd><p>Create a new view by transposing the axes of <var>view</var>.
</p></dd></dl>

<p>This operation does not work on arbitrary array expressions yet. TODO FILL
</p>
<span id="index-diag"></span>
<span id="x_002ddiag"></span><dl>
<dt id="index-diag-1">Function: <strong>diag</strong> <em>view</em></dt>
<dd><p>Equivalent to <code>transpose&lt;0, 0&gt;(view)</code>.
</p></dd></dl>

<span id="index-reverse"></span>
<span id="x_002dreverse"></span><dl>
<dt id="index-reverse-1">Function: <strong>reverse</strong> <em>view axis</em></dt>
<dd><p>Create a new view by reversing axis <var>k</var> of <var>view</var>.
</p></dd></dl>

<p>This is equivalent to <code>view(ra::dots&lt;k&gt;, ra::iota(view.size(k), view.size(k)-1, -1))</code>.
</p>
<p>This operation does not work on arbitrary array expressions yet. TODO FILL
</p>




<span id="index-stencil"></span>
<span id="x_002dstencil"></span><dl>
<dt id="index-stencil-1">Function: <strong>stencil</strong> <em>view lo hi</em></dt>
<dd><p>Create a stencil on <var>view</var> with lower bounds <var>lo</var> and higher bounds <var>hi</var>.
</p></dd></dl>

<p><var>lo</var> and <var>hi</var> are expressions of rank 1 indicating the extent of the stencil on each dimension. Scalars are rank extended, that is, <var>lo</var>=0 is equivalent to <var>lo</var>=(0, 0, ..., 0) with length equal to the rank <code>r</code> of <var>view</var>. The stencil view has twice as many axes as <var>view</var>. The first <code>r</code> dimensions are the same as those of <var>view</var> except that they have their sizes reduced by <var>lo</var>+<var>hi</var>. The last <code>r</code> dimensions correspond to the stencil around each element of <var>view</var>; the center element is at <code>s(i0, i1, ..., lo(0), lo(1), ...)</code>.
</p>
<p>This operation does not work on arbitrary array expressions yet. TODO FILL
</p>
<span id="index-collapse"></span>
<span id="x_002dcollapse"></span><dl>
<dt id="index-collapse-1">Function: <strong>collapse</strong></dt>
<dd><p>TODO
</p></dd></dl>

<span id="index-explode"></span>
<span id="x_002dexplode"></span><dl>
<dt id="index-explode-1">Function: <strong>explode</strong></dt>
<dd><p>TODO
</p></dd></dl>

<span id="index-real_005fpart"></span>
<span id="x_002dreal_005fpart"></span><dl>
<dt id="index-real_005fpart-1">Function: <strong>real_part</strong></dt>
<dd><p>Take real part of a complex number. This can be used as reference.
</p>
<p>See also <a href="#x_002dimag_005fpart"><code>imag_part</code></a>.
</p></dd></dl>

<span id="index-imag_005fpart"></span>
<span id="x_002dimag_005fpart"></span><dl>
<dt id="index-imag_005fpart-1">Function: <strong>imag_part</strong></dt>
<dd><p>Take imaginary part of a complex number. This can be used as reference.
</p>
<p>For example: </p>
<div class="example">
<pre class="verbatim">ra::Small&lt;std::complex&lt;double&gt;, 2, 2&gt; A = {{1., 2.}, {3., 4.}};
imag_part(A) = -2*real_part(A);
cout &lt;&lt; A &lt;&lt; endl;
</pre><pre class="example">-|
(1, -2) (2, -4)
(3, -6) (4, -8)
</pre></div>

<p>See also <a href="#x_002dreal_005fpart"><code>real_part</code></a>.
</p></dd></dl>

<span id="index-format_005farray"></span>
<span id="x_002dformat_005farray"></span><dl>
<dt id="index-format_005farray-1">Function: <strong>format_array</strong> <em>expr [last_axis_separator [second_last_axis_separator ...]]</em></dt>
<dd><p>Formats an array for character output.
</p>
<p>For example:
</p>
<div class="example">
<pre class="verbatim">ra::Small&lt;int, 2, 2&gt; A = {{1, 2}, {3, 4}};
cout &lt;&lt; &quot;case a:\n&quot; &lt;&lt; A &lt;&lt; endl;
cout &lt;&lt; &quot;case b:\n&quot; &lt;&lt; format_array(A) &lt;&lt; endl;
cout &lt;&lt; &quot;case c:\n&quot; &lt;&lt;  format_array(A, &quot;|&quot;, &quot;-&quot;) &lt;&lt; endl;
</pre><pre class="example">-| case a:
1 2
3 4
case b:
1 2
3 4
case c:
1|2-3|4
</pre></div>
</dd></dl>

<p>The shape that might be printed before the expression itself (depending on its type) is not subject to these separators. See <a href="#x_002dnoshape"><code>noshape</code></a>, <a href="#x_002dwithshape"><code>withshape</code></a>.
</p>
<span id="index-noshape"></span>
<span id="index-withshape"></span>
<span id="x_002dnoshape"></span><span id="x_002dwithshape"></span><dl>
<dt id="index-withshape-noshape">Special&nbsp;objects<!-- /@w -->: <strong>withshape noshape</strong></dt>
<dd><p>If either of these objects is sent to <code>std::ostream</code> before an expression object, the shape of that object will or won&rsquo;t be printed.
</p></dd></dl>

<p>If the object has static (compile time) shape, the default is not to print the shape, so <code>noshape</code> isn&rsquo;t necessary, and conversely for <code>withshape</code> if the object has dynamic (runtime) shape. Note that the array readers [<code>operator&gt;&gt;(std::istream &amp;, ...)</code>] expect the shape to be present or not according to the default.
</p>
<p>For example:
</p>
<div class="example">
<pre class="verbatim">ra::Small&lt;int, 2, 2&gt; A = {77, 99};
cout &lt;&lt; &quot;case a:\n&quot; &lt;&lt; A &lt;&lt; endl;
cout &lt;&lt; &quot;case b:\n&quot; &lt;&lt; ra::noshape &lt;&lt; A &lt;&lt; endl;
cout &lt;&lt; &quot;case c:\n&quot; &lt;&lt; ra::withshape &lt;&lt; A &lt;&lt; endl;
</pre><pre class="example">-| case a:
77 99
case b:
77 99
case c:
2
77 99
</pre></div>

<p>but:
</p>
<div class="example">
<pre class="verbatim">ra::Big&lt;int&gt; A = {77, 99};
cout &lt;&lt; &quot;case a:\n&quot; &lt;&lt; A &lt;&lt; endl;
cout &lt;&lt; &quot;case b:\n&quot; &lt;&lt; ra::noshape &lt;&lt; A &lt;&lt; endl;
cout &lt;&lt; &quot;case c:\n&quot; &lt;&lt; ra::withshape &lt;&lt; A &lt;&lt; endl;
</pre><pre class="example">-| case a:
1
2
77 99
case b:
77 99
case c:
1
2
77 99
</pre></div>

<p>Note that in the last example the very shape of <code>ra::Big&lt;int&gt;</code> has runtime size, so that size (the rank of <code>A</code>, that is 1) is printed as part of the shape of <code>A</code>.
</p>
<p>See also <a href="#x_002dformat_005farray"><code>format_array</code></a>.
</p>
<span id="index-start-1"></span>
<span id="x_002dstart"></span><dl>
<dt id="index-start-2">Function: <strong>start</strong> <em>foreign_object</em></dt>
<dd><p>Create a array expression from <var>foreign_object</var>.
</p></dd></dl>

<p><var>foreign_object</var> can be of type <code>std::vector</code> or <code>std::array</code>, a built-in array (<code>int[3]</code>, etc.) or an initializer list, or any object that <code>ra::</code> accepts as scalar (see <a href="#x_002dis_002dscalar"><code>here</code></a>). The resulting expresion has rank and size according to the original object. Compare this with <a href="#x_002dscalar"><code>scalar</code></a>, which will always produce an expression of rank 0.
</p>
<p>Generally one can mix these types with <code>ra::</code> expressions without needing <code>ra::start</code>, but sometimes this isn&rsquo;t possible, for example for operators that must be class members.
</p>
<div class="example">
<pre class="verbatim">std::vector&lt;int&gt; x = {1, 2, 3};
ra::Big&lt;int, 1&gt; y = {10, 20, 30};
cout &lt;&lt; (x+y) &lt;&lt; endl; // same as ra::start(x)+y
// x += y; // error: no match for operator+=
ra::start(x) += y; // ok
</pre><pre class="example">-| 3
  11 22 33
  &rArr; x = { 11, 22, 33 }
</pre></div>

<span id="index-ptr"></span>
<span id="x_002dptr"></span><dl>
<dt id="index-ptr-1">Function: <strong>ptr</strong> <em>pointer [size]</em></dt>
<dd><p>Create vector expression from raw <var>pointer</var>.
</p></dd></dl>

<p>The resulting expression has rank 1 and the size given. If <code>size</code> is not given, the expression has undefined size, and it will need to be matched with other expressions whose size <em>is</em> defined.
</p>
<p><code>ra::</code> doesn&rsquo;t know what is actually accessible through the pointer, so be careful. For instance:
</p>
<div class="example">
<pre class="verbatim">int p[] = {1, 2, 3};
ra::Big&lt;int, 1&gt; v3 {1, 2, 3};
ra::Big&lt;int, 1&gt; v4 {1, 2, 3, 4};
v3 += ra::ptr(p); // ok, shape (3): v3 = {2, 4, 6}
v4 += ra::ptr(p); // undefined, shape (4): bad access to p[3]
// cout &lt;&lt; (ra::ptr(p)+ra::TensorIndex&lt;0&gt;{}) &lt;&lt; endl; // ct error, expression has undefined shape
cout &lt;&lt; (ra::ptr(p, 3)+ra::TensorIndex&lt;0&gt;{}) &lt;&lt; endl; // ok, prints { 1, 3, 5 }
cout &lt;&lt; (ra::ptr(p, 4)+ra::TensorIndex&lt;0&gt;{}) &lt;&lt; endl; // undefined, bad access at p[4]
</pre></div>

<p>Of course in this example one could simply have used <code>p</code> instead of <code>ra::ptr(p)</code>, since the array type retains size information.
</p>
<div class="example">
<pre class="verbatim">v3 += p; // ok
v4 += p; // error checked by ra::, shape clash (4) += (3)
cout &lt;&lt; (p + ra::TensorIndex&lt;0&gt;{}) &lt;&lt; endl; // ok
</pre></div>

<span id="index-scalar"></span>
<span id="x_002dscalar"></span><dl>
<dt id="index-scalar-1">Function: <strong>scalar</strong> <em>expr</em></dt>
<dd><p>Create scalar expression from <var>expr</var>.
</p></dd></dl>

<p>The primary use of this function is to bring a scalar object into the <code>ra::</code> namespace. A somewhat artificial example:
</p>
<div class="example">
<pre class="verbatim">struct W { int x; }
ra::Big&lt;W, 1&gt; w { {1}, {2}, {3} };

// error: no matching function for call to start(W)
// for_each([](auto &amp;&amp; a, auto &amp;&amp; b) { cout &lt;&lt; (a.x + b.x) &lt;&lt; endl; }, w, W {7});

// bring W into ra:: with ra::scalar
for_each([](auto &amp;&amp; a, auto &amp;&amp; b) { cout &lt;&lt; (a.x + b.x) &lt;&lt; endl; }, w, ra::scalar(W {7}));
</pre><pre class="example">-| 8
   9
   10
</pre></div>

<p>See also <a href="#x_002dscalar_002dchar_002dstar"><code>this example</code></a>.
</p>
<p>Since <code>scalar</code> produces an object with rank 0, it&rsquo;s also useful when dealing with nested arrays, even for objects that are already in <code>ra::</code>. Consider:
</p><div class="example">
<pre class="verbatim">using Vec2 = ra::Small&lt;double, 2&gt;;
Vec2 x {-1, 1};
ra::Big&lt;Vec2, 1&gt; c { {1, 2}, {2, 3}, {3, 4} };
// c += x // error: x has shape (2) and c has shape (3)
c += ra::scalar(x); // ok: scalar(x) has shape () and matches c.
</pre><pre class="example">  &rArr; c = { {0, 3}, {1, 4}, {2, 5} }
</pre></div>
<p>The result is {c(0)+x, c(1)+x, c(2)+x}. Compare this with
</p><div class="example">
<pre class="verbatim">c(ra::iota(2)) += x; // c(ra::iota(2)) with shape (2) matches x with shape (2)
</pre><pre class="example">  &rArr; c = { {-1, 2}, {2, 5}, {2, 5} }
</pre></div>
<p>where the result is {c(0)+x(0), c(1)+x(1), c(2)}.
</p>
<span id="index-iter"></span>
<span id="x_002diter"></span><dl>
<dt id="index-iter-1">Function: <strong>iter</strong> <em>&lt;k&gt; (view)</em></dt>
<dd><p>Create iterator over the <var>k</var>-cells of <var>view</var>. If <var>k</var> is negative, it is interpreted as the negative of the frame rank. In the current version of <code>ra::</code>, <var>view</var> may have dynamic or static shape.
</p></dd></dl>

<div class="example">
<pre class="verbatim">ra::Big&lt;int, 2&gt; c {{1, 3, 2}, {7, 1, 3}};
cout &lt;&lt; &quot;max of each row: &quot; &lt;&lt; map([](auto &amp;&amp; a) { return amax(a); }, iter&lt;1&gt;(c)) &lt;&lt; endl;
ra::Big&lt;int, 1&gt; m({3}, 0);
scalar(m) = max(scalar(m), iter&lt;1&gt;(c));
cout &lt;&lt; &quot;max of each column: &quot; &lt;&lt; m &lt;&lt; endl;
m = 0;
for_each([&amp;m](auto &amp;&amp; a) { m = max(m, a); }, iter&lt;1&gt;(c));
cout &lt;&lt; &quot;max of each column again: &quot; &lt;&lt; m &lt;&lt; endl;
</pre><pre class="example">-| max of each row: 2
   3 7
   max of each column: 3
   7 3 3
   max of each column again: 3
   7 3 3
</pre></div>

<p>In the following example, <code>iter</code> emulates <code>scalar</code>. Note that the shape () of <code>iter&lt;1&gt;(m)</code> matches the shape (3) of <code>iter&lt;1&gt;(c)</code>. Thus, each of the 1-cells of <code>c</code> matches against the single 1-cell of <code>m</code>.
</p>
<div class="example">
<pre class="verbatim">m = 0;
iter&lt;1&gt;(m) = max(iter&lt;1&gt;(m), iter&lt;1&gt;(c));
cout &lt;&lt; &quot;max of each column yet again: &quot; &lt;&lt; m &lt;&lt; endl;
</pre><pre class="example">-| max of each column again: 3
   7 3 3
</pre></div>

<p>The following example computes the trace of each of the items [(-1)-cells] of <code>c</code>. </p>
<div class="example">
<pre class="verbatim">ra::Small&lt;int, 3, 2, 2&gt; c = ra::_0 - ra::_1 - 2*ra::_2;
cout &lt;&lt; &quot;c: &quot; &lt;&lt; c &lt;&lt; endl;
cout &lt;&lt; &quot;s: &quot; &lt;&lt; map([](auto &amp;&amp; a) { return sum(diag(a)); }, iter&lt;-1&gt;(c)) &lt;&lt; endl;
</pre><pre class="example">-| c: 0 -2
   -1 -3
   1 -1
   0 -2
   2 0
   1 -1
   s: -3 -1 -1
</pre></div>

<span id="index-sum"></span>
<span id="x_002dsum"></span><dl>
<dt id="index-sum-1">Function: <strong>sum</strong> <em>expr</em></dt>
<dd><p>Return the sum (+) of the elements of <var>expr</var>, or 0 if expr is empty. This sum is performed in unspecified order.
</p></dd></dl>

<span id="index-prod"></span>
<span id="x_002dprod"></span><dl>
<dt id="index-prod-1">Function: <strong>prod</strong> <em>expr</em></dt>
<dd><p>Return the product (*) of the elements of <var>expr</var>, or 1 if expr is empty. This product is performed in unspecified order.
</p></dd></dl>

<span id="index-amax"></span>
<span id="x_002damax"></span><dl>
<dt id="index-amax-1">Function: <strong>amax</strong> <em>expr</em></dt>
<dd><p>Return the maximum of the elements of <var>expr</var>. If <var>expr</var> is empty, return <code>-std::numeric_limits&lt;T&gt;::infinity()</code> if the type supports it, otherwise <code>std::numeric_limits&lt;T&gt;::lowest()</code>, where <code>T</code> is the value type of the elements of <var>expr</var>.
</p></dd></dl>

<span id="index-amin"></span>
<span id="x_002damin"></span><dl>
<dt id="index-amin-1">Function: <strong>amin</strong> <em>expr</em></dt>
<dd><p>Return the minimum of the elements of <var>expr</var>. If <var>expr</var> is empty, return <code>+std::numeric_limits&lt;T&gt;::infinity()</code> if the type supports it, otherwise <code>std::numeric_limits&lt;T&gt;::max()</code>, where <code>T</code> is the value type of the elements of <var>expr</var>.
</p></dd></dl>

<span id="index-early"></span>
<span id="x_002dearly"></span><dl>
<dt id="index-early-1">Function: <strong>early</strong> <em>expr default</em></dt>
<dd><p><var>expr</var> shall be an array expression that returns <code>std::tuple&lt;bool, T&gt;</code>. <var>expr</var> is traversed as by <code>for_each</code>; if the expression ever returns <code>true</code> in the first element of the tuple, traversal stops and the second element is returned. If this never happens, <var>default</var> is returned instead.
</p></dd></dl>

<p>The following definition of elementwise <code>lexicographical_compare</code> relies on <code>early</code>.
</p>
<div class="example">
<pre class="verbatim">template &lt;class A, class B&gt;
inline bool lexicographical_compare(A &amp;&amp; a, B &amp;&amp; b)
{
    return early(map([](auto &amp;&amp; a, auto &amp;&amp; b)
                     { return a==b ? std::make_tuple(false, true) : std::make_tuple(true, a&lt;b); },
                     a, b),
                 false);
}
</pre></div>

<span id="index-any"></span>
<span id="x_002dany"></span><dl>
<dt id="index-any-1">Function: <strong>any</strong> <em>expr</em></dt>
<dd><p>Return <code>true</code> if any element of <var>expr</var> is true, <code>false</code> otherwise. The traversal of the array expression will stop as soon as possible, but the traversal order is not specified.
</p></dd></dl>

<span id="index-every"></span>
<span id="x_002devery"></span><dl>
<dt id="index-every-1">Function: <strong>every</strong> <em>expr</em></dt>
<dd><p>Return <code>true</code> if every element of <var>expr</var> is true, <code>false</code> otherwise. The traversal of the array expression will stop as soon as possible, but the traversal order is not specified.
</p></dd></dl>

<span id="index-sqr"></span>
<span id="x_002dsqr"></span><dl>
<dt id="index-sqr-1">Function: <strong>sqr</strong> <em>expr</em></dt>
<dd><p>Compute the square of <var>expr</var>.
</p></dd></dl>

<span id="index-sqrm"></span>
<span id="x_002dsqrm"></span><dl>
<dt id="index-sqrm-1">Function: <strong>sqrm</strong> <em>expr</em></dt>
<dd><p>Compute the square of the norm-2 of <var>expr</var>, that is, <code>conj(expr)*expr</code>.
</p></dd></dl>

<span id="index-conj"></span>
<span id="x_002dconj"></span><dl>
<dt id="index-conj-1">Function: <strong>conj</strong> <em>expr</em></dt>
<dd><p>Compute the complex conjugate of <var>expr</var>.
</p></dd></dl>

<span id="index-xI"></span>
<span id="x_002dxI"></span><dl>
<dt id="index-xI-1">Function: <strong>xI</strong> <em>expr</em></dt>
<dd><p>Compute <code>(0+1j)</code> times <var>expr</var>.
</p></dd></dl>

<span id="index-rel_005ferror"></span>
<span id="x_002drel_002derror"></span><dl>
<dt id="index-rel_005ferror-1">Function: <strong>rel_error</strong> <em>a b</em></dt>
<dd><p><var>a</var> and <var>b</var> are arbitrary array expressions. Compute the error of <var>a</var> relative to <var>b</var> as
</p>
<p><code>(a==0. &amp;&amp; b==0.) ? 0. : 2.*abs(a, b)/(abs(a)+abs(b))</code>
</p>
</dd></dl>

<span id="index-none-1"></span>
<span id="x_002dnone"></span><dl>
<dt id="index-none-2">Special&nbsp;objects<!-- /@w -->: <strong>none</strong></dt>
<dd><p>Pass <code>none</code> to container constructors to indicate that the contents shouldn&rsquo;t be initialized. This is appropriate when the initialization you have in mind wouldn&rsquo;t fit in a constructor argument. For example:
</p>
<div class="example">
<pre class="verbatim">void old_style_initializer(int m, int n, double *);
ra::Big&lt;double&gt; b({2, 3}, ra::none);
old_style_initializer(2, 3, b.data());
</pre></div>

</dd></dl>

<hr>
<span id="Sources"></span><div class="header">
<p>
Next: <a href="#Indices" accesskey="n" rel="next">Indices</a>, Previous: <a href="#Reference" accesskey="p" rel="prev">Reference</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Sources-1"></span><h2 class="chapter">8 Sources</h2>

<table>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><span id="Abr70"></span>[Abr70]</td><td width="90%">Philip S. Abrams. An APL machine. Technical report SLAC-114 UC-32 (MISC), Stanford Linear Accelerator Center, Stanford University, Stanford, CA, USA, February 1970.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><span id="Ber87"></span>[Ber87]</td><td width="90%">Robert Bernecky. An introduction to function rank. ACM SIGAPL APL Quote Quad, 18(2):39–43, December 1987.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><span id="bli17"></span>[bli17]</td><td width="90%">The Blitz++ meta-template library. <a href="http://blitz.sourceforge.net">http://blitz.sourceforge.net</a>, November 2017.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><span id="Cha86"></span>[Cha86]</td><td width="90%">Gregory J. Chaitin. Physics in APL2, June 1986.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><span id="FI68"></span>[FI68]</td><td width="90%">Adin D. Falkoff and Kenneth Eugene Iverson. APL\360 User’s manual. IBM Thomas J. Watson Research Center, August 1968.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><span id="FI73"></span>[FI73]</td><td width="90%">Adin D. Falkoff and Kenneth Eugene Iverson. The design of APL. IBM Journal of Research and Development, 17(4):5–14, July 1973.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><span id="FI78"></span>[FI78]</td><td width="90%">Adin D. Falkoff and Kenneth Eugene Iverson. The evolution of APL. ACM SIGAPL APL, 9(1):30– 44, 1978.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><span id="J-S"></span>[J S]</td><td width="90%">J Primer. J Software, <a href="https://www.jsoftware.com/help/primer/contents.htm">https://www.jsoftware.com/help/primer/contents.htm</a>, November 2017.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><span id="Mat"></span>[Mat]</td><td width="90%">MathWorks. MATLAB documentation, <a href="https://www.mathworks.com/help/matlab/">https://www.mathworks.com/help/matlab/</a>, November 2017.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><span id="num17"></span>[num17]</td><td width="90%">NumPy. <a href="http://www.numpy.org">http://www.numpy.org</a>, November 2017.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><span id="Ric08"></span>[Ric08]</td><td width="90%">Henry Rich. J for C programmers, February 2008.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><span id="SSM14"></span>[SSM14]</td><td width="90%">Justin Slepak, Olin Shivers, and Panagiotis Manolios. An array-oriented language with static rank polymorphism. In Z. Shao, editor, ESOP 2014, LNCS 8410, pages 27–46, 2014.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><span id="Vel01"></span>[Vel01]</td><td width="90%">Todd Veldhuizen. Blitz++ user’s guide, February 2001.</td></tr>
<tr><td width="10%"></td></tr>
<tr><td width="10%"><span id="Wad90"></span>[Wad90]</td><td width="90%">Philip Wadler. Deforestation: transforming programs to eliminate trees. Theoretical Computer Science, 73(2): 231&ndash;248, June 1990. <a href="https://doi.org/10.1016/0304-3975%2890%2990147-A">https://doi.org/10.1016/0304-3975%2890%2990147-A</a></td></tr>
</table>

<hr>
<span id="Indices"></span><div class="header">
<p>
Previous: <a href="#Sources" accesskey="p" rel="prev">Sources</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#Indices" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Indices-1"></span><h2 class="unnumbered">Indices</h2>

<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Indices_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-J"><b>J</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-V"><b>V</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-W"><b>W</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-X"><b>X</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-cp" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Indices_cp_letter-A">A</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-amax"><code>amax</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-amin"><code>amin</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-any"><code>any</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-APL">APL</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Why-C_002b_002b">Why C++</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-at"><code>at</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Indices_cp_letter-B">B</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-BLIS">BLIS</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility">Compatibility</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Blitz_002b_002b">Blitz++</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Overview">Overview</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Blitz_002b_002b-1">Blitz++</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-libraries">Other libraries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Blitz_002b_002b-2">Blitz++</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Extension">Extension</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-broadcasting_002c-singleton">broadcasting, singleton</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rank-extension">Rank extension</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-broadcasting_002c-singleton-1">broadcasting, singleton</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Slicing">Slicing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-built_002din-array">built-in array</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility">Compatibility</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Indices_cp_letter-C">C</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-cast"><code>cast</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cell">cell</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rank-polymorphism">Rank polymorphism</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-collapse"><code>collapse</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-conj"><code>conj</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-container">container</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Using-the-library">Using the library</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Indices_cp_letter-D">D</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-diag"><code>diag</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Indices_cp_letter-E">E</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-early"><code>early</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-every"><code>every</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-explode"><code>explode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Indices_cp_letter-F">F</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-FFTW">FFTW</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility">Compatibility</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-foreign-type">foreign type</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility">Compatibility</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-format_005farray"><code>format_array</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-for_005feach"><code>for_each</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-frame">frame</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rank-polymorphism">Rank polymorphism</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-from"><code>from</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Indices_cp_letter-G">G</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Guile">Guile</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility">Compatibility</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Indices_cp_letter-I">I</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-imag_005fpart"><code>imag_part</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-iter"><code>iter</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Indices_cp_letter-J">J</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-J">J</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Why-C_002b_002b">Why C++</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Indices_cp_letter-N">N</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-none"><code>none</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Containers-and-views">Containers and views</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-none-1"><code>none</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-noshape"><code>noshape</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Numpy">Numpy</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rank-extension">Rank extension</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Numpy-1">Numpy</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rank-extension">Rank extension</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Numpy-2">Numpy</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility">Compatibility</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Indices_cp_letter-O">O</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-OpenGL">OpenGL</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility">Compatibility</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-order_002c-column_002dmajor">order, column-major</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Containers-and-views">Containers and views</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-order_002c-row_002dmajor">order, row-major</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rank-polymorphism">Rank polymorphism</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-other-libraries_002c-interfacing-with">other libraries, interfacing with</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility">Compatibility</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Indices_cp_letter-P">P</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-pack"><code>pack</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pick"><code>pick</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ply"><code>ply</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prod"><code>prod</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ptr"><code>ptr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Python">Python</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility">Compatibility</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Indices_cp_letter-R">R</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-real_005fpart"><code>real_part</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rel_005ferror"><code>rel_error</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-reverse"><code>reverse</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Indices_cp_letter-S">S</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-scalar"><code>scalar</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shape-agreement_002c-prefix">shape agreement, prefix</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rank-extension">Rank extension</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shape-agreement_002c-suffix">shape agreement, suffix</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rank-extension">Rank extension</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sqr"><code>sqr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sqrm"><code>sqrm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-start"><code>start</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compatibility">Compatibility</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-start-1"><code>start</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-stencil"><code>stencil</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sum"><code>sum</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Indices_cp_letter-T">T</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-transpose"><code>transpose</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Indices_cp_letter-V">V</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-view">view</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Containers-and-views">Containers and views</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Indices_cp_letter-W">W</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-where"><code>where</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-withshape"><code>withshape</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-wrank"><code>wrank</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Indices_cp_letter-X">X</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-xI"><code>xI</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reference">Reference</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Indices_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-J"><b>J</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-V"><b>V</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-W"><b>W</b></a>
 &nbsp; 
<a class="summary-letter" href="#Indices_cp_letter-X"><b>X</b></a>
 &nbsp; 
</td></tr></table>


<div class="footnote">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h3><a id="FOOT1" href="#DOCF1">(1)</a></h3>
<p>/ə&rsquo;ɹ-eɪ/, I guess.</p>
<h3><a id="FOOT2" href="#DOCF2">(2)</a></h3>
<p>Cf. <a href="https://en.wikipedia.org/wiki/Dope_vector"><em>dope vector</em></a></p>
<h3><a id="FOOT3" href="#DOCF3">(3)</a></h3>
<p>Examples given without context assume that one has declared <code>using std::cout;</code>, etc.</p>
<h3><a id="FOOT4" href="#DOCF4">(4)</a></h3>
<p>The brace-list constructors of rank 2 and higher aren&rsquo;t supported on types of runtime rank, because in the C++ grammar, a nested initializer list doesn&rsquo;t always define a rank unambiguously.</p>
<h3><a id="FOOT5" href="#DOCF5">(5)</a></h3>
<p>You can still use pointers or <code>std::initializer_list</code>s for shape by wrapping them in the functions <code>ptr</code> or <code>vector</code>, respectively.</p>
<h3><a id="FOOT6" href="#DOCF6">(6)</a></h3>
<p>The brace-list constructors aren&rsquo;t rank extending, because giving the ravel is incompatible with rank extension. They are size-strict —you must give every element.</p>
<h3><a id="FOOT7" href="#DOCF7">(7)</a></h3>
<p>Prefix agreement is chosen for <code>ra::</code> because of the availability of a <a href="#The-rank-conjunction">rank conjunction</a> [<a href="#Sources">Ber87</a>]
 and <a href="#Cell-iteration">cell iterators of arbitrary rank</a>. This allows rank extension to be performed at multiple axes of an array expression.</p>
<h3><a id="FOOT8" href="#DOCF8">(8)</a></h3>
<p><code>&amp;&amp;</code>, <code>||</code> are short-circuiting as array operations; the elements of the second operand won&rsquo;t be evaluated if the elements of the first one evaluate to <code>false</code> or <code>true</code>, respectively. Note that if both operands are of rank 0 and at least one of them is an <code>ra::</code> object, they is no way to preserve the behavior of <code>&amp;&amp;</code> and <code>||</code> with built in types and avoid evaluating both, since the overloaded operators <a href="http://en.cppreference.com/w/cpp/language/operators">are normal functions</a>.</p>
<h3><a id="FOOT9" href="#DOCF9">(9)</a></h3>
<p>It used to be the case that <code>TensorIndex</code> was <b>Indexable</b> but not <b>Ravelable</b>, which forced all the other <b>Ravelable</b> types to provide <code>at(i...)</code> so that they could be mixed with <code>TensorIndex</code> in expressions. Now that <code>TensorIndex</code> is also <b>Ravelable</b>, this distinction may disappear in the future with <code>at(i...)</code> being provided at a higher level.</p>
<h3><a id="FOOT10" href="#DOCF10">(10)</a></h3>
<p>For example, in <code>Big&lt;int, 1&gt; { 1, 2 } + Small&lt;int 2&gt; { 3, 4 }</code>, the driver is the second term.</p>
<h3><a id="FOOT11" href="#DOCF11">(11)</a></h3>
<p>The full driver selection logic is in &lsquo;<samp>ra/opcheck.H</samp>&rsquo;</p>
</div>
<hr>



</body>
</html>
