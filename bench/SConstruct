# -*- mode: Python -*-
# -*- coding: utf-8 -*-

# (c) Daniel Llorens - 2015-2016

# This library is free software; you can redistribute it and/or modify it under
# the terms of the GNU Lesser General Public License as published by the Free
# Software Foundation; either version 3 of the License, or (at your option) any
# later version.

# SConstruct for ra/bench
# FIXME Shared pieces with {examples,test,doc}/SConstruct

import os, string, atexit
from colorama import Fore, Back, Style
from os.path import join, abspath
from subprocess import call

# FIXME pick BLAS flags from here.
try:
    Import('top')
except:
    top = {}

# put into library...
def take_from_environ(env, var, wrapper=(lambda x: x), default=None):
    if var in os.environ and os.environ[var]!='':
        env[var] = wrapper(os.environ[var])
    elif default is not None:
        env[var] = default

vars = Variables()
vars.AddVariables(PathVariable('variant_dir', 'build directory', '.', PathVariable.PathIsDirCreate))

env = Environment(options=vars,
                  ENV=dict([(k, os.environ[k] if k in os.environ else '')
                            for k in ['PATH', 'HOME', 'TERM', 'LD_RUN_PATH', 'DYLD_LIBRARY_PATH',
                                      'RPATH', 'LIBRARY_PATH', 'TEXINPUTS', 'GCC_COLORS', 'BOOST_ROOT',
                                      'RA_USE_BLAS']]))
variant_dir = env['variant_dir']

for var, default in [('CC', 'gcc'), ('CXX', 'g++'), ('FORTRAN', 'gfortran')]:
    take_from_environ(env, var, default=default)
for var in ['FORTRANFLAGS', 'LINKFLAGS', 'CCFLAGS', 'CXXFLAGS']:
    take_from_environ(env, var, wrapper=string.split)
for var in ['RPATH', 'LIBPATH']:
    take_from_environ(env, var, wrapper=lambda x: [x])

arch = os.popen('./config.guess').read()

if arch.find('86-apple-darwin') >= 0:
    archflags=['-march=native', '-Wa,-q']
    ld_blas = {'LINKFLAGS': ' -framework vecLib ', 'LIBS': []}
else:
    archflags=['-march=native']
    ld_blas = {'LINKFLAGS': '', 'LIBS': ['blas']}

env.Append(CPPPATH=['..', 'bench'],
           CCFLAGS=archflags if str(env['CCFLAGS']).strip()=='' else '',
           CXXFLAGS=['-std=c++1z', '-Wall', '-Werror', '-fdiagnostics-color=always', '-Wno-unknown-pragmas',
                     '-finput-charset=UTF-8', '-fextended-identifiers',
                     '-Wno-error=strict-overflow',
                     #'-Wconversion',
                     # '-funsafe-math-optimizations', # TODO Test with this.
                 ])

env_blas = env.Clone()
if 'RA_USE_BLAS' in env['ENV'] and env['ENV']['RA_USE_BLAS']=='1':
    print("[%s] BLAS will be used." % Dir('.').path)
    env_blas.Append(CPPDEFINES={'RA_USE_BLAS': 1})
    env_blas.Append(LINKFLAGS=ld_blas['LINKFLAGS'])
    env_blas.Append(LIBS=ld_blas['LIBS'])
else:
    print("[%s] BLAS won't be used." % Dir('.').path)

# from top SConstruct
def to_test(env, source, args):
    """
    Run program with args to produce a check stamp. The name of the first source
    is used to generate the name of the stamp.
    """

    class tester:
        def __init__(self, args):
            self.args = args

        def __call__(self, target, source, env):
            print "-> running %s \n___________________" % str(self.args)
            r = os.spawnl(os.P_WAIT, self.args[0], self.args[0], *self.args[1:])
            print "^^^^^^^^^^^^^^^^^^^"
            print 'r ', r
            if not r:
                print "PASSED %s" % str(self.args)
                call(['touch', target[0].abspath])
            else:
                print "FAILED %s" % str(self.args)
            return r

    stamp = File(join(variant_dir, str(source[0])) + string.join(args[1:]) + '.check')
    return env.Command(stamp, source, tester(args))

def to_test_ra(env_, source, target='', cxxflags=[], cppdefines=[]):
    if len(cxxflags)==0 or len(cppdefines)==0:
        env = env_
    else:
        env = env_.Clone()
        env.Append(CXXFLAGS=cxxflags + ['-U' + k for k in cppdefines.keys()], CPPDEFINES=cppdefines)
    if len(target)==0:
        target = source
    obj = env.Object(target, [source + '.C'])
    test = env.Program(target, obj)
    to_test(env, test, [test[0].abspath])

def print_summary():
    from SCons.Script import GetBuildFailures
    test_item_tally = 0
    test_tally = 0
    build_tally = 0

    print '\n' + Style.BRIGHT + 'Summary for ra/bench' + Style.RESET_ALL + '\n--------'
    for bf in GetBuildFailures():
        if str(bf.node).endswith('.check') and (bf.status > 0):
            print (Style.BRIGHT + Fore.RED + '%s ' + Style.RESET_ALL + Fore.RESET + ' failed (%d)') \
                % (bf.node, bf.status)
            test_item_tally += bf.status
            test_tally += 1
        else:
            print (Style.BRIGHT + Fore.YELLOW + '%s ' + Style.RESET_ALL + Fore.RESET + ' failed (%s)') \
                % (bf.node, bf.errstr)
            build_tally += 1

    print '%d targets failed to build.' % build_tally
    print '%d tests failed with %d total failures.' % (test_tally, test_item_tally)

if 'skip_summary' not in top:
    atexit.register(print_summary)

[to_test_ra(env, bench)
 for bench in ['bench-dot', 'bench-reduce-sqrm',
               'bench-gemv', 'bench-sum-rows', 'bench-sum-cols',
               'bench-pack', 'bench-from',
               'bench-stencil1', 'bench-stencil2', 'bench-stencil3']]

[to_test_ra(env_blas, bench)
 for bench in ['bench-gemm']]
