\input texinfo   @c -*-texinfo-*-
@documentencoding UTF-8
@c %**start of header
@setfilename ra-ra.info
@settitle ra-ra: An array library for C++1z
@c %**end of header

@set VERSION 0.1
@set UPDATED 2016 September 23

@copying
ra-ra (version @value{VERSION}, updated @value{UPDATED})

(c) Daniel Llorens 2016

@smalldisplay
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
@end smalldisplay
@end copying

@dircategory C++ libraries
@direntry
* ra-ra: (ra-ra.info).  Expression template and multidimensional array library for C++.
@end direntry

@titlepage
@title ra-ra
@subtitle version @value{VERSION}, updated @value{UPDATED}
@author Daniel Llorens
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@ifnottex
@node Top
@top ra-ra

@insertcopying

This manual is a work in progress. There are errors and whole sections yet to be written.

@menu
* Introduction::          Array programming and C++.
* Usage::                 Everything you can do with ra-ra.
* Reference::             Systematic list of types and functions.
* Hazards::               User beware.
* The future::            Could be even better.
@end menu

@end ifnottex

@iftex
@shortcontents
@end iftex

@node Introduction
@chapter Introduction

A multidimensional array is a container whose elements can be looked up using a multi-index (i₀, i₁, ...). Each of the indices i₀, i₁, ... has a fixed range [0, n₀), [0, n₁), ... so the array is `rectangular'. The number of indices in the multi-index is the @dfn{rank} of the array, and the list (n₀, n₁, ... nᵣ₋₁) is the @dfn{shape} of the array.

Often we deal with multidimensional @emph{expressions} where the elements aren't stored anywhere, but are computed on demand when the expression is looked up. In this general sense, an `array' is just a function of integers with a rectangular domain.

Arrays (also called @dfn{matrices}, @dfn{vectors}, or @dfn{tensors}) are everywhere in math and many other fields, and it is enormously useful to be able to manipulate arrays as individual entities rather than as aggregates. Not only is

@verbatim
A = B+C;
@end verbatim

much more compact and easier to read than

@verbatim
for (int i=0; i!=m; ++i)
    for (int j=0; j!=n; ++j)
        for (int k=0; k!=p; ++k)
            A(i, j, k) = B(i, j, k)+C(i, j, k);
@end verbatim

but it's also safer and less redundant. For example, the order of the loops may be something you don't really care about.

However, if array operations are implemented naively, a piece of code such as @code{A = B+C} may result in the creation of a temporary to hold @code{B+C} which is then assigned to @code{A}. Needless to say this is very wasteful if the arrays involved are large.

Fortunately the problem is almost as old as aggregate data types, and other programming languages have addressed it with optimizations such as `loop fusion' REF, `drag along' REF, or `deforestation' REF. In the C++ context the technique of `expression templates' was pioneered in the late 90s by libraries such as Blitz++ REF. It works by making @code{B+C} into an `expression object' which holds references to its arguments and executes the sum only when its elements are looked up. The compiler removes the temporary expression objects during optimization, so that @code{A=B+C} results (in principle) in the same generated code as the complicated nested loop above.

@menu
* Design and features::   APL and J are the right model.
* Other libraries::       Inspiration and desperation.
@end menu

@node Design and features
@section What you can do with array programming

What can you do with an array? Is an array an abstract interface, or is it also the implementation that makes it an array? Which operations are expensive, which are cheap?




@node Other libraries
@section Other array libraries

Here I try to list the C++ array libraries that I know of, or libraries that I think deserve a mention for the way they deal with arrays. It is not an extensive review, since I have only used a few of these libraries myself. Please follow the links if you want to be properly informed.

Since the C++ standard library doesn't offer a standard multidimensional array type, some libraries for specific tasks (linear algebra operations, finite elements, optimization) offer an accessory array library, which may be more or less general. Other libraries have generic array interfaces without needing to provide an array type. FFTW is a good example, maybe because it isn't C++!

C++ offers multidimensional arrays as a legacy feature from C, e.g. @code{int a[3][4]}. These decay to pointers when you do nearly anything with them, don't know their own sizes or rank, and are generally too limited. However, they do have one important property, called @dfn{rank polymorphism}, which we'll have more to say about later REF.

The C++ standard library also offers a number of containers that can be used as rank-1 arrays, of which the most important are @code{<array>}, @code{<vector>} and @code{<valarray>}. Neither supports higher ranks out of the box, but @code{<valarray>} offers array operations for rank-1 arrays. ra-ra makes use of @code{<array>} and @code{<vector>} for storage and bootstrapping so we'll mention these containers from time to time.

Blitz++ (REF) pioneered the use of expression templates in C++. It supported higher rank arrays, as high as it was practical in C++ at the time, but not dynamic rank. It also supported small arrays with compile time sizes, and convenience features such as Fortran-order constructors and arbitrary lower bounds for the array indices (both of which ra-ra doesn't support on purpose). Storage for large arrays was reference-counted, while in ra-ra that is optional but not the default. It placed a strong emphasis on performance, with array traversal methods such as blocking, space filling curves, etc. To date it remains, I believe, one of the most general array libraries for C++. However, the implementation had to fight the limitations of C++98 and it offered no general rank extension mechanism.

@node Usage
@chapter Usage

Shows how to use.

@menu
* Using ra-ra::                ra-ra is a header-only library.
* Containers and views::       Data objects.
* Array operations::           Building and executing expressions.
* Rank extension::             How array operands are matched.
* Slicing::                    Subscripting is a special operation.
* Other special operations::   Useful but not essential.
* Special objects::            Not arrays, yet arrays.
* Internals::                  Laid bare.
@end menu

@node Using ra-ra
@section Using ra-ra

ra-ra is a header only library with no dependencies, so you just need to place the ra/ folder somewhere in your include path and add

@example
@verbatim
#include <ra/operators.H>
#include <ra/io.H>
@end verbatim
@end example

to the top of your sources. A C++14 compiler with partial C++17 support is required. At time of writing this means gcc 6.2 with @code{-std=c++1z}. Most tests pass under clang 3.9 with a couple of extra flags (@code{-Wno-missing-braces}, @code{-DRA_OPTIMIZE_SMALLVECTOR=0}).


@node Containers and views
@section Containers and views

ra-ra offers two kinds of data objects. The first is the @dfn{container}, whose defining characteristic is that it owns its data. Creating a container uses memory and destroying it causes that memory to be freed.

There are three kinds of containers: fixed size, fixed rank/variable size, and variable rank. Here fixed means `compile time constant' while variable is normally a run time constant. (Some variable size arrays can be resized but variable rank arrays cannot normally have their rank changed. Instead, you create a new container or view with the rank you want.)

For example:

@example
@verbatim
{
    ra::Small<double, 2, 3> a(0.);       // a fixed size 2x3 array
    ra::Owned<double, 2> b({2, 3}, 0.);  // a variable size 2x3 array
    ra::Owned<double> c({2, 3}, 0.);     // a variable rank 2x3 array
    // a, b, c destroyed at end of scope
}
@end verbatim
@end example

The main reason to have all these different types is performance; the compiler can do a much better job when it knows the size or the rank of the array. Also, the sizes of a fixed size array do not need to be stored in memory so if you have thousands of small arrays it certainly pays off to use the fixed size types for them. Fixed size or fixed rank arrays are also safer to use; sometimes ra-ra will be able to detect errors in the sizes or ranks of array operands at compile time, if the appropriate types are used.

Container constructors come in two forms. The first takes a single argument which is copied into the new container. This argument provides shape information if the container type requires it.

@example
@verbatim
ra::Small<double, 2, 3> a = 0.;  // 0. is copied into a
ra::Small<double, 2, 3> b = a;   // the contents of a are copied into b
ra::Owned<double> c = a;         // c takes the size of a and a is copied into c
ra::Owned<double> d = 0.;        // d is a rank-0 array with one element d()==0.
@end verbatim
@end example

The second form takes two arguments, one giving the shape, the second the contents.

@example
@verbatim
ra::Owned<double, 2> a({2, 3}, 1.);  // a has size 2x3 and be filled with 1.
ra::Owned<double> b({2, 3}, a);      // b has size 2x3 and a is copied into b
@end verbatim
@end example

The last example may result in an error if the shape of @code{a} and @{2,@w{ }3@} don't match. Here the shape of @code{1.} (which is @{@}) matches @{2,@w{ }3@} by a mechanism of rank extension (@pxref{Rank extension}).

A @dfn{view} is similar to a container in that it points to actual data in memory. However, the view doesn't own that data and destroying the view won't affect it. For example:

@example
@verbatim
ra::Owned<double> c({2, 3}, 0.);     // a variable rank 2x3 array
{
    auto c1 = c(1);                  // the first row of array c
    // c1 is destroyed here
}
// can still use c here
@end verbatim
@end example

The data accessed through a view is the data of the `root' container, so modifying the first will be reflected in the latter.

@example
@verbatim
ra::Owned<double> c({2, 3}, 0.);
auto c1 = c(1);
c1(2) = 9.;                      // c(1, 2) = 9.
@end verbatim
@end example

Just as for containers, there are separate types of views depending on whether the size is known at compile time, the rank is known at compile time but the size is not, or neither the size nor the rank are known at compile time. ra-ra has functions to create the most common kinds of views:

@example
@verbatim
ra::Owned<double> c({2, 3}, 0.);
auto ct = transpose<1, 0>(c);
auto cr = reverse(c, 0);
@end verbatim
@end example

However, views can point to anywhere in memory and that memory doesn't have to belong to a ra-ra container. For example:

@example
@verbatim
int raw[6] = {1, 2, 3, 4, 5, 6};
ra::View<int> v1({{2, 3}, {3, 1}}, raw); // view with sizes {2, 3} strides {3, 1}
ra::View<int> v2({2, 3}, raw);           // same, default C (row-major) strides
@end verbatim
@end example

Containers can be treated as views and the container types convert implicitly to the view types of the same `fixedness'. Therefore if you declare a function

@example
@verbatim
void f(ra::View<int, 3> & v);
@end verbatim
@end example

you may pass it an object of type @code{ra::Owned<int, 3>}.


@node Array operations
@section Array operations

To apply an operation to each element of an array, use the function @code{for_each}. The array is traversed in an order that is decided by the library.

@example
@verbatim
ra::Small<double, 2, 3> a = {1, 2, 3, 4, 5, 6};
real s = 0.;
for_each([&s](auto && a) { s+=a; }, a);
@end verbatim
@result{} s = 21.
@end example

To construct an array expression but stop short of executing it, use the function @code{map}. The expression will be executed implicitly when it is assigned to a view, printed out, etc.

@example
@verbatim
using T = ra::Small<double, 2, 2>;
T a = {1, 2, 3, 4};
T b = {10, 20, 30, 40};
T c = map([](auto && a, auto && b) { return a+b; }, a, b); // (1)
@end verbatim
@result{} c = @{ 11, 22, 33, 44 @}
@end example

Expressions may take any number of arguments and be nested arbitrarily.

@example
@verbatim
T d = 0;
for_each([](auto && a, auto && b, auto && d) { d = a+b; }, a, b, d); // same as (1)
for_each([](auto && ab, auto && d) { d = ab; },
map([](auto && a, auto && b) { return a+b; }, a, b), d); // same as (1)
@end verbatim
@end example

The operator of an expression may return a reference and you may assign to an expression in that case. ra-ra will complain if the expression is somehow not assignable.

@example
@verbatim
T d = 0;
map([](auto & d) -> decltype(auto) { return d; }, d) // just pass d along
= map([](auto && a, auto && b) { return a+b; }, a, b); // same as (1)
@end verbatim
@end example

ra-ra defines many shortcuts for common array operations. You can of course just do:

@example
@verbatim
T d = a+b; // same as (1)
@end verbatim
@end example

@node Rank extension
@section Rank extension

Rank extension is the mechanism that allows operations such as @code{R+S} to work even when @code{R}, @code{S} may have different ranks. The idea is an interpolation of the following basic cases.

Suppose first that @code{R} and @code{S} have the same rank. We require that the shapes be the same. Then the shape of @code{R+S} will be the same as the shape of either @code{R} or @code{S} and the elements of @code{R+S} will be

@quotation
@code{(R+S)(i₀ i₁ ... i₍ᵣ₋₁₎) = R(i₀ i₁ ... i₍ᵣ₋₁₎) + S(i₀ i₁ ... i₍ᵣ₋₁₎)}
@end quotation

where @code{r} is the rank of @code{R}.

Now suppose that @code{S} has rank 0. The shape of @code{R+S} is the same as the shape of @code{R} and the elements of @code{R+S} will be

@quotation
@code{(R+S)(i₀ i₁ ... i₍ᵣ₋₁₎) = R(i₀ i₁ ... i₍ᵣ₋₁₎) + S()}.
@end quotation

The two rules above are supported by all primitive array languages, e.g. Matlab REF. But suppose that @code{S} has rank @code{s}, where @code{0<s<r}. Looking at the expressions above, it seems natural to define @code{R+S} by

@quotation
@code{(R+S)(i₀ i₁ ... i₍ₛ₋₁₎ ... i₍ᵣ₋₁₎) = R(i₀ i₁ ... i₍ₛ₋₁₎ ... i₍ᵣ₋₁₎) + S(i₀ i₁ ... i₍ₛ₋₁₎)}.
@end quotation

That is, after we run out of indices in @code{S}, we simply repeat the elements. We have aligned the shapes so:

@quotation
@verbatim
[n₀ n₁ ... n₍ₛ₋₁₎ ... n₍ᵣ₋₁₎]
[n₀ n₁ ... n₍ₛ₋₁₎]
@end verbatim
@end quotation

This rank extension rule is used by J REF and is known as @dfn{prefix agreement}. (The opposite rule of @dfn{suffix agreement} is used, for example, in Numpy REF.)

You can verify that the prefix agreement rule is distributive. Therefore it can be applied to nested expressions or to expressions with any number of arguments. This rule is applied systematically throughout ra-ra, even in assignment expressions. For example,

@example
@verbatim
ra::Small<int, 3> x {3, 5, 9};
ra::Small<int, 3, 2> a = x; // assign x(i) to each a(i, j)
@end verbatim
@result{} a = @{@{3, 3@}, @{5, 5@}, @{9, 9@}@}
@end example

@example
@verbatim
ra::Small<int, 3> x(0.);
ra::Small<int, 3, 2> a = {1, 2, 3, 4, 5, 6};
x += a; // sum the rows a
@end verbatim
@result{} x = @{3, 7, 11@}
@end example

@example
@verbatim
ra::Owned<double, 3> a({5, 3, 3}, ra::_0);
ra::Owned<double, 2> b({5}, 0.);
b += transpose<0, 1, 1>(a); // b(i) = ∑ⱼ a(i, j, j)
@end verbatim
@result{} b = @{0, 3, 6, 9, 12@}
@end example

@node Slicing
@section Slicing

Slicing is an array extension of the subscripting operation. However, tradition and convenience have given it a special status in most array languages, together with some peculiar semantics that ra-ra supports.

The form of the scripting operator @code{A(i₀, i₁, ...)} makes it plain that @code{A} is a function of @code{rank(A)} integer arguments. Therefore an array extension is immediately available through @code{map}. For example:

@example
@verbatim
ra::Owned<double, 1> a = {1., 2., 3., 4.};
ra::Owned<int, 1> i = {1, 3};
map(a, i) = 77.;
@end verbatim
@result{} a = @{1., 77., 3, 77.@}
@end example

Just as with any use of @code{map}, array arguments are subject to the prefix agreement rule.

@example
@verbatim
ra::Owned<double, 2> a({2, 2}, {1., 2., 3., 4.});
ra::Owned<int, 1> i = {1, 0};
ra::Owned<double, 1> b = map(a, i, 0);
@end verbatim
@result{} b = @{3., 1.@} // @{a(1, 0), a(0, 0)@}
@end example

@example
@verbatim
ra::Owned<int, 1> j = {0, 1};
b = map(a, i, j);
@end verbatim
@result{} b = @{3., 2.@} // @{a(1, 0), a(0, 1)@}
@end example

The latter is a form of sparse subscripting.

Most array operations (e.g. @code{+}) are defined through @code{map} in this way. For example, @code{A+B+C} is defined as @code{map(+, A, B, C)} (or the equivalent @code{map(+, map(+, A, B), C)}). Not so for the subscripting operation:


@example
@verbatim
ra::Owned<double, 2> A({2, 2}, {1., 2., 3., 4.});
ra::Owned<int, 1> i = {1, 0};
ra::Owned<int, 1> j = {0, 1};
// {{A(i₀, j₀), A(i₀, j₁)}, {A(i₁, j₀), A(i₁, j₁)}}
ra::Owned<double, 2> b = A(i, j);
@end verbatim
@result{} b = @{@{3., 4.@}, @{1., 2.@}@}
@end example

@code{A(i, j, ...)} is the @emph{outer product} of the indices @code{(i, j, ...)} with operator @code{A}.

This operation sees much more use in practice than @code{map(A, i, j ...)}. Besides, when the subscripts @code{i, j, ...} are scalars or @dfn{linear ranges} (integer sequences of the form @code{(o, o+s, ..., o+s*(n-1))}, the subscripting can be performed inmediately at constant cost and without needing to construct an expression object. This optimization is called @dfn{beating} REF. ra-ra is not smart enough to know when an arbitrary expression might be a linear range, so the following special objects are provided:

@deffn @w{Special object} iota count [start:0 [step:1]]
Create a linear range @code{start, start+step, ... start+step*(count-1)}.
@end deffn

This can used anywhere an array expression is expected.

@example
@verbatim
ra::Owned<int, 1> a = ra::iota(4, 3 -2);
@end verbatim
@result{} a = @{3, 1, -1, -3@}
@end example

Here, @code{b} and @code{c} are @code{View}s (@pxref{Containers and views}).
@example
@verbatim
ra::Owned<int, 1> a = {1, 2, 3, 4, 5, 6};
auto b = a(iota(3));
auto c = a(iota(3, 3));
@end verbatim
@result{} a = @{1, 2, 3@}
@result{} a = @{4, 5, 6@}
@end example

@deffn @w{Special object} all
Create a linear range @code{0, 1, ... (nᵢ-1)} when used as a subscript for the @code{i}-th argument of a subscripting expression.
@end deffn

This object cannot stand alone as an array expression. All the examples below result in @code{View} objects:

@example
@verbatim
ra::Owned<int, 2> a({3, 2}, {1, 2, 3, 4, 5, 6});
auto b = a(ra::all, ra::all); // (1) a view of the whole of a
auto c = a(iota(3), iota(2)); // same as (1)
auto d = a(iota(3), ra::all); // same as (1)
auto e = a(ra:all, iota(2)); // same as (1)
auto f = a(0, ra::all); // first row of a
auto g = a(ra::all, 1); // second column of a
@end verbatim
@end example

@deffn @w{Special object} dots<n>
Equivalent to as many instances of @code{ra::all} as indicated by @code{n}. Each instance takes the place of one argument to the subscripting operation.
@end deffn

@example
@verbatim
auto h = a(ra::all, ra::all); // same as (1)
auto i = a(ra::all, ra::dots<1>); // same as (1)
auto j = a(ra::dots<2>); // same as (1)
auto k = a(ra::dots<0>, ra::dots<2>); // same as (1)
auto l = a(0, ra::dots<1>); // first row of a
auto m = a(ra::dots<1>, 1); // second column of a
@end verbatim
@end example

This is useful when writing rank-generic code, see @code{examples/maxwell.C} in the distribution for an example.


@node Other special operations
@section Other special operations

@menu
* The rank conjunction::       J comes to C++.
@end menu

@node The rank conjunction
@subsection The rank conjunction

@node Special objects
@section Special objects

@node Internals
@section Internals

@node Reference
@chapter Reference

@defun map op args ...
Create array expression that applies @var{op} to @var{args} ...
@end defun

For example:
@example
@verbatim
ra::Owned<double, 1> x = map(cos, ra::Small<double, 1> {0.});
@end verbatim
@result{} x = @{ 1. @}
@end example

@defun for_each op args ...
Create array expression that applies @var{op} to @var{args} ..., and traverse it.
@end defun

@var{op} should normally return @code{void}. For example:
@example
@verbatim
double s = 0.;
for_each([&s](auto && a) { s+=a; }, ra::Small<double, 1> {1., 2., 3})
@end verbatim
@result{} s = 6.
@end example

@defun pack <type> args ...
Create array expression that brace-constructs @var{type} from @var{args}.
@end defun

@defun cast <type> arg
Create array expression that casts @var{arg} into @var{type}.
@end defun

@defun pick select args ...
Create array expression that selects the first of @var{args} if @var{select} is 0, the second if @var{select} is 1, and so on. The arguments that are not selected are not looked up.
@end defun

This function cannot be defined using @var{map}, because @var{map} looks up each one of its arguments before calling @var{op}.

For example:
@example @c cf examples/readme.C [100].
@verbatim
    ra::Small<int, 3> s {2, 1, 0};
    ra::Small<char const *, 3> z = pick(s, s*s, s+s, sqrt(s));
@end verbatim
  @result{} z = @{1.41421, 2, 0@}
@end example

@defun where pred true false
Create array expression that selects @var{true} if @var{pred} is @code{true}, and @var{false} if @var{pred} is @code{false}. The argument that is not selected is not looked up.
@end defun

For example:
@example
@verbatim
    ra::Owned<double, 1> s {1, -1, 3, 2};
    s = where(s>=2, 2, s); // saturate s
@end verbatim
  @result{} s = @{1, -1, 2, 2@}
@end example

@defun from op ... args
Create outer product expression. This is defined as @math{E(i00, i01 ..., i10, i11, ..., ...) = op(arg0(i01, i01 ...), arg1(i10, i11, ...) ...)}.
@end defun

For example:
@example
@verbatim
    ra::Owned<double, 1> a {1, 2, 3};
    ra::Owned<double, 1> b {10, 20, 30};
    ra::Owned<double, 2> axb = from([](auto && a, auto && b) { return a*b; }, a, b)
@end verbatim
  @result{} axb = @{@{10, 20, 30@}, @{20, 40, 60@}, @{30, 60, 90@}@}
@end example

@example
@verbatim
    ra::Owned<int, 1> i {2, 1};
    ra::Owned<int, 1> j {0, 1};
    ra::Owned<double, 2> A({3, 2}, {1, 2, 3, 4, 5, 6});
    ra::Owned<double, 2> Aij = from(A, i, j)
@end verbatim
  @result{} Aij = @{@{6, 5@}, @{4, 3@}@}
@end example

The last example is more or less how @code{A(i, j)} is actually implemented.

@defun wrank <input_rank ...> op ... args
Wrap op using a rank conjunction (@pxref{The rank conjunction}).
@end defun

For example:
@example
@verbatim
@end verbatim
  @result{} x = 0
@end example

@defun transpose <axes ...> view
Create a new view by transposing the axes of @var{view}.
@end defun

This operation does not work on arbitrary array expressions yet. TODO FILL

@defun diag view
Equivalent to @code{transpose<0, 0>(view)}.
@end defun

@defun reverse view axis
Create a new view by reversing axis @var{k} of @var{view}.
@end defun

This is equivalent to @code{view(ra::dots<k>, ra::iota(view.size(k), view.size(k)-1, -1))}.

This operation does not work on arbitrary array expressions yet. TODO FILL

@defun stencil view lo hi
Create a stencil on @var{view} with lower bounds @var{lo} and higher bounds @var{hi}.
@end defun

@var{lo} and @var{hi} are rank-1 expressions indicating the extent of the stencil on each dimension. Scalars are rank extended, that is, @var{lo}=0 is equivalent to @var{lo}=(0, 0, ..., 0) with length equal to the rank @code{r} of @var{view}. The stencil view has twice as many axes as @var{view}. The first @code{r} dimensions are the same as those of @var{view} except that they have their sizes reduced by @var{lo}+@var{hi}. The last @code{r} dimensions correspond to the stencil around each element of @var{view}; the center element is at @code{s(i0, i1, ..., lo(0), lo(1), ...)}.

This operation does not work on arbitrary array expressions yet. TODO FILL

@node Hazards
@chapter Hazards

ra-ra applies its principles systematically and that can result in
surprises.

@enumerate
@item
Item 0
@item
Item 1
@item
Item 2
@end enumerate

@node The future
@chapter The future

Wishlist and acknowledged bugs.

@c @node Concept Index
@c @unnumbered Concept Index
@c @printindex cp
@c @node Function Index
@c @unnumbered Function Index
@c @printindex fn

@bye
